<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="author" content="zchengsite, 1451426471@qq.com" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  
  <title>网络基础 | coder的特殊身份</title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

<meta name="generator" content="Hexo 4.2.1"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/"><img src="/images/avatar.png" alt=""></a>
    <div class="nickname"><a href="/"></a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">分类</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  
  
  
  
  
  
  
  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">网络基础</div>
      <div class="post-attach">
        <span class="post-pubtime">2020-06-23</span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签 | tags"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="查看 计算机网络 标签">
                    <b>#</b> 计算机网络
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>参考：<a href="https://www.nowcoder.com/discuss/401108?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=5" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/401108?type=post&amp;order=time&amp;pos=&amp;page=1&amp;subType=5</a></p>
<h1 id="网络层级"><a href="#网络层级" class="headerlink" title="网络层级"></a>网络层级</h1><p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945797_d17b9305-4536-46ba-a569-c63a9ea52e8f.png?ynotemdtimestamp=1593654556079" alt="OSI 参考模型与 TCP/IP 的关系"></p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h1 id="TCP、UDP"><a href="#TCP、UDP" class="headerlink" title="TCP、UDP"></a>TCP、UDP</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945751_a430b41e-5bfa-43b0-9b67-7c73fd86d5af.png?ynotemdtimestamp=1593654556079" alt="UDP 头部格式"></p>
<ul>
<li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li>
<li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li>
<li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计。</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>​    <img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711211900229.png?ynotemdtimestamp=1593654556079" alt="image-20200711211900229"></p>
<p>​    <code>TCP</code> 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<p>​    TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议：</p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。</li>
</ul>
<h3 id="报文头部"><a href="#报文头部" class="headerlink" title="报文头部"></a><strong>报文头部</strong></h3><p>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</p>
<ol>
<li><strong>序号，</strong>占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；</li>
<li><strong>确认号，</strong>占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li>
<li><strong>数据偏移，</strong>占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</li>
<li><strong>保留，</strong>占6位，保留今后使用，但目前应都位0；</li>
<li><strong>紧急URG，</strong>当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</li>
<li><strong>确认ACK，</strong>仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；</li>
<li><strong>推送PSH，</strong>当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</li>
<li><strong>复位RST，</strong>当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</li>
<li><strong>同步SYN，</strong>在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；</li>
<li><strong>终止FIN</strong>，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；</li>
<li><strong>窗口，</strong>占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>
<li><strong>检验和，</strong>占2字节，校验首部和数据这两部分；</li>
<li><strong>紧急指针，</strong>占2字节，指出本报文段中的紧急数据的字节数；</li>
<li><strong>选项，</strong>长度可变，定义一些其他的可选的参数。</li>
</ol>
<p>建立一个 TCP 连接是需要客户端与服务器端达成三个信息的共识：</p>
<ul>
<li><strong>Socket</strong>：由 IP 地址和端口号组成</li>
<li><strong>序列号</strong>：用来解决乱序问题等</li>
<li><strong>窗口大小</strong>：用来做流量控制</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945745_43606570-83b8-468d-9079-c2d345208310.png?ynotemdtimestamp=1593654556079" alt="img"></p>
<h3 id="三次握手（客户端触发）"><a href="#三次握手（客户端触发）" class="headerlink" title="三次握手（客户端触发）"></a>三次握手（客户端触发）</h3><p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945744_b95c9091-976e-49ea-bcb9-6e14d73f777f.png?ynotemdtimestamp=1593654556079" alt="img-connect"></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711205403782.png?ynotemdtimestamp=1593654556079" alt="image-20200711205403782"></p>
<ul>
<li>第一次握手：Client将标志位SYN置为1，随机产生一个值<code>seq=J</code>，并将该数据包发送给Server，Client进入<code>SYN_SENT</code>状态，等待Server确认。</li>
<li>第二次握手：Server收到数据包后由标志位<code>SYN=1</code>知道Client请求建立连接，Server将标志位<code>SYN</code>和<code>ACK</code>都置为1，<code>ack=J+1</code>，随机产生一个值<code>seq=K</code>，并将该数据包发送给Client以确认连接请求，Server进入<code>SYN_RCVD</code>状态。</li>
<li>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给Server，Server检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，Client和Server进入<code>ESTABLISHED</code>状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945853_01213c30-037e-4d0c-8d19-e191216721e8.png?ynotemdtimestamp=1593654556079" alt="TCP 头格式"></p>
<p>​    （1）<strong>序列号：</strong>Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p>
<p>​    在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p> （2）<strong>确认应答号：</strong><code>Ack</code>序号，占32位，只有<code>ACK</code>标志位为1时，确认序号字段才有效，<code>Ack=Seq+1</code>。<strong>用来解决不丢包的问题。</strong></p>
<p> （3）<strong>标志位：</strong>共6个，即<code>URG</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>SYN</code>、<code>FIN</code>等，具体含义如下：  （A）<strong>URG：</strong>紧急指针（urgent pointer）有效。  （B）<strong>ACK：</strong>确认序号有效。  （C）<strong>PSH：</strong>接收方应该尽快将这个报文交给应用层。  （D）<strong>RST：</strong>重置连接，表示 TCP 连接中出现异常必须强制断开连接。  （E）<strong>SYN：</strong>发起一个新连接。  （F）<strong>FIN：</strong>释放一个连接。表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</p>
<h4 id="为什么是三次握手？不是两次、四次？"><a href="#为什么是三次握手？不是两次、四次？" class="headerlink" title="为什么是三次握手？不是两次、四次？"></a>为什么是三次握手？不是两次、四次？</h4><p>三个方面分析三次握手的原因：</p>
<ul>
<li><p><strong><em>避免历史连接</em>：</strong>三次握手才可以阻止重复历史连接的初始化（主要原因）</p>
<p>三次握手的<strong>首要原因是为了防止旧的重复连接初始化造成混乱。</strong></p>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945899_6e3dc5dd-4f07-4e55-8e55-4455250e10b8.png?ynotemdtimestamp=1593654556079" alt="三次握手避免历史连接"></p>
</li>
</ul>
<ul>
<li><p><strong><em>同步双方初始序列号\</em></strong>：三次握手才可以同步双方的初始序列号</p>
<p>TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：</p>
<ul>
<li>接收方可以去除重复的数据；</li>
<li>接收方可以根据数据包的序列号按序接收；</li>
<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</li>
</ul>
<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 <code>SYN</code> 报文的时候，需要服务端回一个 <code>ACK</code> 应答报文，表示客户端的 SVN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，<strong>这样一来一回，才能确保双方的初始序列号能被可靠的同步。</strong></p>
</li>
</ul>
<p>  而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。</p>
<ul>
<li><p><strong><em>避免资源浪费</em>：</strong>三次握手才可以避免资源浪费</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945870_abd2e227-537d-40d3-a6cd-f853bb960166.png?ynotemdtimestamp=1593654556079" alt="两次握手会造成资源浪费"></p>
<p>两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求 <code>SYN</code> 报文，而造成重复分配资源。</p>
</li>
</ul>
<p><strong>采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。这就很明白了，防止了服务器端的一直等待而浪费资源。</strong></p>
<h3 id="四次挥手（客户端-服务端触发）"><a href="#四次挥手（客户端-服务端触发）" class="headerlink" title="四次挥手（客户端/服务端触发）"></a>四次挥手（客户端/服务端触发）</h3><p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945748_f98d949d-8456-41ef-b5c6-0b86bd796684.png?ynotemdtimestamp=1593654556079" alt="img"></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711202729020.png?ynotemdtimestamp=1593654556079" alt="image-20200711202729020"></p>
<p>​    由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p>
<ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手?"></a><strong>为什么要四次挥手?</strong></h4><p>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。</p>
<p>TCP是<strong>全双工模式</strong>，这就意味着，当<code>主机1</code>发出<code>FIN报文段</code>时，只是表示<code>主机1</code>已经没有数据要发送了，<code>主机1</code>告诉<code>主机2</code>， 它的数据已经全部发送完毕了；</p>
<p>但是这个时候<code>主机1</code>还是可以接受来自<code>主机2</code>的数据；当<code>主机2</code>返回ACK报文段时，表示它已经知道<code>主机1</code>没有数据发送了，但是<code>主机2</code>还是可以发送数据到<code>主机1</code>的;</p>
<p>当<code>主机2</code>也发送了FIN 报文段时，这个时候就表示<code>主机2</code>也没有数据要发送了，就会告诉<code>主机1</code>，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。如果要正确的理解四次分手的原理，就需要了解四次分手过程中的状态变化。</p>
<p><strong>FIN_WAIT_1:</strong></p>
<p>这个状态要好好解释一下，其实<code>FIN_WAIT_1</code>和<code>FIN_WAIT_2</code>状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：</p>
<ul>
<li><code>FIN_WAIT_1</code>状态实际上是当<code>SOCKET</code>在<code>ESTABLISHED</code>状态时， 它想主动关闭连接，向对方发送了<code>FIN报文</code>，此时该<code>SOCKET</code>即进入到<code>FIN_WAIT_1</code>状态。</li>
<li>当对方回应<code>ACK报文</code>后，则进入到<code>FIN_WAIT_2</code>状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应<code>ACK报文</code>，所以<code>FIN_WAIT_1</code>状态一般是比较难见到的，而<code>FIN_WAIT_2</code>状态还有时常常可以用<code>netstat</code>看到。 <strong>（主动方）</strong></li>
</ul>
<p><strong>FIN_WAIT_2：</strong></p>
<p>上面已经详细解释了这种状态，实际上<code>FIN_WAIT_2</code>状态下的<code>SOCKET</code>，表示<code>半连接</code>。也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你（ACK信息），稍后再关闭连接。 <strong>（主动方）</strong></p>
<p><strong>CLOSE_WAIT：</strong></p>
<p>这种状态的含义其实是<strong>表示在等待关闭</strong>。</p>
<p>当对方<code>close</code>一个<code>SOCKET</code>后发送FIN 报文给自己，你会毫无疑问地会回应一个<code>ACK报文</code>给对方，此时则进入到<code>CLOSE_WAIT</code>状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个 <code>SOCKET</code>，发送<code>FIN报文</code>给对方，也即<code>关闭连接</code>。</p>
<p>所以你在<code>CLOSE_WAIT</code>状态下，需要完成的事情是等待你去关闭连接。<strong>（被动方）</strong></p>
<p><strong>LAST_ACK:</strong></p>
<p>这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。<strong>（被动方）</strong></p>
<p><strong>TIME_WAIT:</strong></p>
<p>表示收到了对方的<code>FIN报文</code>，并发送出了<code>ACK报文</code>，就等<code>2MSL</code>后即可回到<code>CLOSED</code>可用状态了。</p>
<p>如果<code>FIN_WAIT1状态</code>下，收到了对方同时带<code>FIN标志</code>和<code>ACK标志</code>的报文时，可以直接进入到<code>TIME_WAIT状态</code>，而无须经过<code>FIN_WAIT_2状态</code>。<strong>(主动方)</strong></p>
<p><strong>CLOSED:</strong> 表示连接中断。</p>
<h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a><strong>TCP拥塞控制</strong></h3><p>窗口：</p>
<ul>
<li>RWND（Receiver Window）：保证少丢包；接收端维护大小，每次ACK时会告诉发送端窗口大小；</li>
<li>CWND（Congestion Window）：根据链路负载而变化，发送方自己维护。为了控制发送方速度。</li>
</ul>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712180859344.png?ynotemdtimestamp=1593654556079" alt="image-20200712180859344"></p>
<p>RTO：超时重传</p>
<p>BDP：Bandwidth Delay</p>
<p>图解：</p>
<p>拥塞避免算法：</p>
<p>Reno</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712182219461.png?ynotemdtimestamp=1593654556079" alt="image-20200712182219461"></p>
<p>每次收到数据包+1，达到某一最高点后，回到最初点重新开始。</p>
<p>假设：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712182247442.png" alt="image-20200712182247442"></p>
<p>问题：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712182338926.png" alt="image-20200712182338926"></p>
<h4 id="1-慢开始和拥塞避免"><a href="#1-慢开始和拥塞避免" class="headerlink" title="1. 慢开始和拥塞避免"></a><strong>1. 慢开始和拥塞避免</strong></h4><p>发送方维持一个拥塞窗口 <code>cwnd ( congestion window )</code>的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p>
<p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<h5 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a><strong>慢开始算法</strong></h5><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。</p>
<p>因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p>
<p>通常在刚刚开始发送报文段时，先把<code>拥塞窗口 cwnd</code> 设置为一个<code>最大报文段MSS</code>的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大<code>发送方的拥塞窗口 cwnd</code> ，可以使分组注入到网络的速率更加合理。</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711213256997.png?ynotemdtimestamp=1593654556079" alt="image-20200711213256997"></p>
<p><strong>每经过一个传输轮次，拥塞窗口 cwnd 就加倍</strong>。<strong>一个传输轮次所经历的时间其实就是往返时间RTT。</strong>不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p>
<p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置<code>cwnd=1</code>，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再<code>逐渐增大cwnd</code>。</p>
<p>为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要<code>设置一个慢开始门限ssthresh状态变量</code>。慢开始门限ssthresh的用法如下：</p>
<ul>
<li>当 <code>cwnd &lt; ssthresh</code> 时，使用上述的慢开始算法。</li>
<li>当 <code>cwnd &gt; ssthresh</code> 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 <code>cwnd = ssthresh</code> 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</li>
</ul>
<h5 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a><strong>拥塞避免</strong></h5><p>让拥塞窗口cwnd缓慢地增大，即每经过<strong>一个往返时间RTT</strong>就把发送方的<strong>拥塞窗口cwnd加1，而不是加倍</strong>。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711213356793.png?ynotemdtimestamp=1593654556079" alt="image-20200711213356793"></p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。</p>
<p>然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711213418967.png?ynotemdtimestamp=1593654556079" alt="image-20200711213418967"></p>
<h4 id="2-快重传和快恢复"><a href="#2-快重传和快恢复" class="headerlink" title="2. 快重传和快恢复"></a><strong>2. 快重传和快恢复</strong></h4><p><strong>快重传</strong></p>
<p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711213604702.png?ynotemdtimestamp=1593654556079" alt="image-20200711213604702"></p>
<p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。</p>
<p>显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。</p>
<p>但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及    早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。</p>
<p><strong>快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。</strong></p>
<p>由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p>
<p><strong>快恢复</strong></p>
<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<ul>
<li>当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。</li>
<li>与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ul>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200711213616426.png?ynotemdtimestamp=1593654556079" alt="image-20200711213616426"></p>
<h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a><strong>DDOS攻击</strong></h3><p>即<code>拒绝服务攻击</code>，其目的是<strong>使计算机或者网络无法提供正常服务</strong>。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。</p>
<p><strong>带宽攻击</strong>指以极大的通信量冲击网络，使得所有可用网络资源都被消耗殆尽，最后导致合法的用户请求无法通过。连通性攻击指用大量的连接请求冲击计算机，使得所有可用的操作系统资源都被消耗殆尽，最终计算机无法再处理合法用户的请求。</p>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p><strong>利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。</strong></p>
<p>服务器接收到连接请求（<code>SYN=i</code>）将此信息加入未连接队列，并发送请求给客户端（<code>SYN=j，ACK=i+1</code>）,此时进入<code>SYN_RECV状态</code>。客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，被丢弃。</p>
<p>攻击主机通过发送大量<code>SYN包</code>填满连接队列，导致正常SYN包被拒绝服务。</p>
<p>​    我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入<code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>ACK + SYN</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的 SYN 接收队列（未连接队列）</strong>，使得服务器不能为正常用户服务。</p>
<p>​    在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为<code>半连接（half-open connect）</code>，此时Server处于<code>SYN_RCVD状态</code>，当收到ACK后，Server转入<code>ESTABLISHED状态</code>。</p>
<p>​    SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。</p>
<p>​    SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nap | grep SYN_RECV</span><br></pre></td></tr></table></figure>

<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945889_eec220c3-12b1-4842-a0ed-4022a96f8edb.jpg?ynotemdtimestamp=1593654556079" alt="SYN 攻击"></p>
<h4 id="避免SYN攻击"><a href="#避免SYN攻击" class="headerlink" title="避免SYN攻击"></a>避免SYN攻击</h4><h5 id="1-避免-SYN-攻击方式一"><a href="#1-避免-SYN-攻击方式一" class="headerlink" title="1. *避免 SYN 攻击方式一***"></a><em>1. *</em>避免 SYN 攻击方式一***</h5><p>其中一种解决方式是通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p>
<ul>
<li>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog</span><br></pre></td></tr></table></figure>

<ul>
<li>SYN_RCVD 状态连接的最大个数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_max_syn_backlog</span><br></pre></td></tr></table></figure>

<ul>
<li>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_abort_on_overflow</span><br></pre></td></tr></table></figure>

<h5 id="2-避免SYN攻击方式二"><a href="#2-避免SYN攻击方式二" class="headerlink" title="2. 避免SYN攻击方式二\"></a><strong><em>2. 避免SYN攻击方式二\</em></strong></h5><p>先来看下Linux 内核的 <code>SYN</code> （未完成连接建立）队列与 <code>Accpet</code> （已完成连接建立）队列是如何工作的？</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945905_bfea9c58-d209-46ab-ac6a-dbda534f1f9c.png?ynotemdtimestamp=1593654556079" alt="正常流程"></p>
<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会将其加入到内核的「 SYN 队列」；</li>
<li>接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；</li>
<li>服务端接收到 ACK 报文后，从「 SYN 队列」移除放入到「 Accept 队列」；</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945940_1a0c3e7c-bde2-452b-99fc-c5b98f9bd4b7.png?ynotemdtimestamp=1593654556079" alt="应用程序过慢"></p>
<p>应用程序过慢：</p>
<ul>
<li>如果应用程序过慢时，就会导致「 Accept 队列」被占满。</li>
</ul>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945906_76868a86-b939-4594-826f-d89295c39fc9.png?ynotemdtimestamp=1593654556079" alt="受到 SVN 攻击"></p>
<p>受到 SYN 攻击：</p>
<ul>
<li>如果不断受到 SYN 攻击，就会导致「 <code>SYN 队列</code>」被占满。</li>
</ul>
<p><code>tcp_syncookies</code> 的方式可以应对 SYN 攻击的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies &#x3D; 1</span><br></pre></td></tr></table></figure>

<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945906_11d041e8-a97b-457e-8b85-227110fe0069.png?ynotemdtimestamp=1593654556079" alt="tcp_syncookies 应对 SYN 攻击"></p>
<ul>
<li>当 「 SYN 队列」满之后，后续服务器收到 SYN 包，不进入「 SYN 队列」；</li>
<li>计算出一个 <code>cookie</code> 值，再以 SYN + ACK 中的「序列号」返回客户端，</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。</li>
<li>最后应用通过调用 <code>accpet()</code> socket 接口，从「 Accept 队列」取出的连接。</li>
</ul>
<h3 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h3><blockquote>
<p><a href="https://blog.csdn.net/Scythe666/article/details/51996268" target="_blank" rel="noopener">https://blog.csdn.net/Scythe666/article/details/51996268</a></p>
<p><a href="https://blog.csdn.net/weixin_41047704/article/details/85340311" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41047704/article/details/85340311</a></p>
</blockquote>
<p>发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了<code>优化算法（Nagle算法）</code>，将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行<code>封包</code>。</p>
<h4 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h4><p><code>TCP粘包</code>就是指<strong>发送方发送的若干包数据到达接收方时粘成了一包</strong>，从接收缓冲区来看，<strong>后一包数据的头紧接着前一包数据的尾</strong>，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p>
<h4 id="造成粘包原因？"><a href="#造成粘包原因？" class="headerlink" title="造成粘包原因？"></a>造成粘包原因？</h4><h5 id="（1）发送方原因"><a href="#（1）发送方原因" class="headerlink" title="（1）发送方原因"></a>（1）发送方原因</h5><p>TCP默认使用<code>Nagle算法</code>（<strong>主要作用：减少网络中报文段的数量</strong>），而Nagle算法主要做两件事：</p>
<ul>
<li>只有上一个分组得到确认，才会发送下一个分组；</li>
<li>收集多个小分组，在一个确认到来时一起发送</li>
</ul>
<p><strong>Nagle算法造成了发送方可能会出现粘包问题。</strong></p>
<h5 id="（2）接收方原因"><a href="#（2）接收方原因" class="headerlink" title="（2）接收方原因"></a>（2）接收方原因</h5><p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。</p>
<p>实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，<strong>如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存</strong>，应用程序就有可能读取到多个首尾相接粘到一起的包。</p>
<h4 id="什么时候处理粘包现象？"><a href="#什么时候处理粘包现象？" class="headerlink" title="什么时候处理粘包现象？"></a>什么时候处理粘包现象？</h4><ol>
<li>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象；</li>
<li>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了；</li>
</ol>
<h5 id="如何处理粘包现象？"><a href="#如何处理粘包现象？" class="headerlink" title="如何处理粘包现象？"></a>如何处理粘包现象？</h5><h5 id="（1）发送方"><a href="#（1）发送方" class="headerlink" title="（1）发送方"></a>（1）发送方</h5><p>对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p>
<h5 id="（2）接收方"><a href="#（2）接收方" class="headerlink" title="（2）接收方"></a>（2）接收方</h5><p>接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p>
<h5 id="（2）应用层"><a href="#（2）应用层" class="headerlink" title="（2）应用层"></a>（2）应用层</h5><p>应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p>
<p><strong>解决办法</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</span><br></pre></td></tr></table></figure>

<p><strong>格式化数据</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。</span><br></pre></td></tr></table></figure>

<p><strong>发送长度</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</span><br></pre></td></tr></table></figure>

<h4 id="UDP会不会产生粘包问题？"><a href="#UDP会不会产生粘包问题？" class="headerlink" title="UDP会不会产生粘包问题？"></a>UDP会不会产生粘包问题？</h4><p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p>
<p>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p>
<p><strong>举个例子</strong>：</p>
<p>有三个数据包，大小分别为<code>2k</code>、<code>4k</code>、<code>6k</code>，如果采用<code>UDP</code>发送的话，不管接受方的接收缓存有多大，我们必须要进行至少三次以上的发送才能把数据包发送完，但是使用TCP协议发送的话，我们只需要接受方的接收缓存有12k的大小，就可以一次把这3个数据包全部发送完毕。</p>
<h3 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a><strong>为什么客户端最后还要等待2MSL？</strong></h3><p><code>MSL（Maximum Segment Lifetime）</code>，TCP允许不同的实现可以设置不同的MSL值：</p>
<p>原因有二：</p>
<ul>
<li><strong>保证TCP协议的全双工连接能够可靠关闭；</strong></li>
<li><strong>保证这次连接的重复数据段从网络中消失；</strong></li>
</ul>
<p><strong>第一点</strong>：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p>
<p><strong>第二点</strong>：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。</p>
<p>一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p>
<h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a><strong>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</strong></h3><p>建立连接的时候， 服务器在<code>LISTEN状态</code>下，收到建立连接请求的<code>SYN报文</code>后，把ACK和SYN放在一个报文里发送给客户端。</p>
<p>而关闭连接时，服务器收到对方的<code>FIN报文</code>时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p>
<h3 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a><strong>如果已经建立了连接，但是客户端突然出现故障了怎么办？</strong></h3><p>TCP还设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h3 id="TCP数据包的编号（SEQ）作用？"><a href="#TCP数据包的编号（SEQ）作用？" class="headerlink" title="TCP数据包的编号（SEQ）作用？"></a><strong>TCP数据包的编号（SEQ）作用？</strong></h3><p>发送的时候，TCP 协议为每个包<strong>编号</strong>（<code>sequence number，简称 SEQ</code>），以便接收的一方按照顺序还原。万一发生丢包，也可以知道丢失的是哪一个包。</p>
<p>第一个包的编号是一个随机数。为了便于理解，这里就把它称为1号包。假定这个包的负载长度是100字节，那么可以推算出下一个包的编号应该是101。这就是说，每个数据包都可以得到两个编号：<strong>自身的编号，以及下一个包的编号。</strong>接收方由此知道，应该按照什么顺序将它们还原成原始文件。（<code>ack=seq+len</code>）</p>
<p>操作系统不会去处理TCP数据包里面的数据。一旦组装好TCP数据包，就把他们转交给应用程序。TCP数据包里面有一个端口（port）参数，就是用来指定转交给监听该端口的应用程序。</p>
<p>TCP协议为了做到效率与可靠性的统一，设计了一个<code>慢启动机制</code>。</p>
<ul>
<li>开始的时候，发送得较慢，然后根据丢包的情况，调整速率；</li>
<li>如果不丢包，就加快发送速度；</li>
<li>如果丢包，就降低发送速度。</li>
</ul>
<p>默认情况下，接收方收到两个TCP数据包，就发送一个确定消息。</p>
<p>ACK携带两个信息：</p>
<ul>
<li>期待要收到下一个数据包的编号和接收方的接收窗口的剩余容量。</li>
<li>TCP是双向的，所以双方都需要发送ACK。</li>
</ul>
<p>如果发送方接收到三个连续的重复ACK，或者超时了还没有收到任何ACK，就会确认丢包。</p>
<h3 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a><strong>TCP如何保证可靠传输？</strong></h3><ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>TCP 的接收端会丢弃重复的数据。</strong></li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h4 id="1）ARQ协议"><a href="#1）ARQ协议" class="headerlink" title="1）ARQ协议"></a><strong>1）ARQ协议</strong></h4><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。</p>
<p>它通过使用<strong>确认</strong>和<strong>超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括<strong>停止等待ARQ协议</strong>和<strong>连续ARQ协议</strong>。</p>
<h5 id="停止等待ARQ协议"><a href="#停止等待ARQ协议" class="headerlink" title="停止等待ARQ协议"></a><strong>停止等待ARQ协议</strong></h5><ul>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li>
<li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li>
</ul>
<p>优点： 简单</p>
<p>缺点： 信道利用率低，等待时间长</p>
<h6 id="1-无差错情况"><a href="#1-无差错情况" class="headerlink" title="1) 无差错情况:"></a><strong>1) 无差错情况:</strong></h6><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<h6 id="2-出现差错情况（超时重传）"><a href="#2-出现差错情况（超时重传）" class="headerlink" title="2) 出现差错情况（超时重传）:"></a><strong>2) 出现差错情况（超时重传）:</strong></h6><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。</p>
<p>另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<h6 id="3-确认丢失和确认迟到"><a href="#3-确认丢失和确认迟到" class="headerlink" title="3) 确认丢失和确认迟到"></a><strong>3) 确认丢失和确认迟到</strong></h6><ul>
<li><strong>确认丢失</strong> <strong>：</strong>确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：</li>
<li><ul>
<li>1、丢弃这个重复的M1消息，不向上层交付。</li>
<li>2、向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li>
</ul>
</li>
<li><strong>确认迟到</strong> <strong>：</strong>确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：</li>
<li><ul>
<li>1、A收到重复的确认后，直接丢弃。</li>
<li>2、B收到重复的M1后，也直接丢弃重复的M1。</li>
</ul>
</li>
</ul>
<h5 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a><strong>连续ARQ协议</strong></h5><p><strong>连续 ARQ 协议可提高信道利用率。</strong></p>
<p>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p>比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h4 id="2）滑动窗口和流量控制"><a href="#2）滑动窗口和流量控制" class="headerlink" title="2）滑动窗口和流量控制"></a><strong>2）滑动窗口和流量控制</strong></h4><p>TCP 利用滑动窗口实现流量控制。流量控制是为了<strong>控制发送方发送速率，保证接收方来得及接收</strong>。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h4 id="3）拥塞控制"><a href="#3）拥塞控制" class="headerlink" title="3）拥塞控制"></a><strong>3）拥塞控制</strong></h4><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p>
<p>拥塞控制就是<strong>为了防止过多的数据注入到网络</strong>中，这样就可以使网络中的路由器或链路不致过载。</p>
<p>拥塞控制<strong>所要做的都有一个前提，就是网络能够承受现有的网络负荷</strong>。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。</p>
<p>流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。</li>
</ul>
<p>没有 <code>FRR</code>，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。</p>
<p>有了 <code>FRR</code>，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，<code>快速重传和恢复（FRR）</code>能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<h3 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a><strong>TCP短连接</strong></h3><p>模拟一下TCP短连接的情况：</p>
<p>​    <strong>client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。</strong></p>
<p>短连接的优点是：</p>
<p><strong>管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</strong>。</p>
<h3 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a><strong>TCP长连接</strong></h3><p>我们再模拟一下长连接的情况：<strong>client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</strong></p>
<p>TCP的保活功能主要为服务器应用提供。</p>
<p>如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。</p>
<p><strong>如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态</strong>：</p>
<ul>
<li><strong>客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。</strong></li>
<li><strong>客户主机已经崩溃，并且关闭或者正在重新启动。</strong></li>
<li><ul>
<li><strong>上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。</strong></li>
</ul>
</li>
<li><strong>客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</strong></li>
<li><strong>客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。</strong></li>
</ul>
<h3 id="长连接短链接优缺点？"><a href="#长连接短链接优缺点？" class="headerlink" title="长连接短链接优缺点？"></a><strong>长连接短链接优缺点？</strong></h3><p><strong>长连接</strong>可以<strong>省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong>。</p>
<p>对于频繁请求资源的客户来说，较适用长连接。不过这里<strong>存在一个问题</strong>，<strong>存活功能的探测周期太长</strong>，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。</p>
<p>在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，<strong>Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候</strong>，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。</p>
<p><strong>短连接</strong>对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户<strong>请求频繁</strong>，将在<strong>TCP的建立和关闭操作上浪费时间和带宽</strong>。</p>
<h2 id="TCP协议和UDP协议的区别是什么"><a href="#TCP协议和UDP协议的区别是什么" class="headerlink" title="TCP协议和UDP协议的区别是什么"></a>TCP协议和UDP协议的区别是什么</h2><p><strong><em>1. 连接\</em></strong></p>
<ul>
<li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li>
<li>UDP 是不需要连接，即刻传输数据。</li>
</ul>
<p><strong><em>2. 服务对象\</em></strong></p>
<ul>
<li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li>
<li>UDP 支持一对一、一对多、多对多的交互通信</li>
</ul>
<p><strong><em>3. 可靠性\</em></strong></p>
<ul>
<li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</li>
<li>UDP 是尽最大努力交付，不保证可靠交付数据。</li>
</ul>
<p><strong><em>4. 拥塞控制、流量控制\</em></strong></p>
<ul>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ul>
<p><strong><em>5. 首部开销\</em></strong></p>
<ul>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
</ul>
<h2 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h2><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li><code>FTP</code> 文件传输</li>
<li><code>HTTP</code> / <code>HTTPS</code></li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><h2 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h2><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="1）-一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><a href="#1）-一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？" class="headerlink" title="1） 一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？"></a><strong>1） 一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</strong></h3><p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945690_37244af3-7b6c-41b0-ab9d-a22bde051426.png?ynotemdtimestamp=1593654556079" alt="img"></p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。</p>
<ul>
<li>首先主要是<strong>文件描述符限制</strong>，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目；</li>
<li>另一个是<strong>内存限制</strong>，每个 TCP 连接都要占用一定内存，操作系统是有限的。</li>
</ul>
<h3 id="2）-为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><a href="#2）-为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？" class="headerlink" title="2） 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？"></a><strong>2） 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</strong></h3><p>​    TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p>
<h3 id="3）-为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？"><a href="#3）-为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？" class="headerlink" title="3） 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？"></a><strong>3） 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</strong></h3><p>​    先说说 TCP 是如何计算负载数据长度：</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20200405/4215031_1586092945779_6d1ba64b-9311-4408-aed9-2b6a2d905955.png?ynotemdtimestamp=1593654556079" alt="img"></p>
<p>​    其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p>
<p>​    大家这时就奇怪了问：“ UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p>
<p>​    这么一问，确实感觉 UDP 「包长度」是冗余的。</p>
<p>​    <strong>因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code>字节的整数倍。</strong></p>
<p>​    如果去掉 UDP 「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以小林觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</p>
<h3 id="4）-TCP性能问题的原因？"><a href="#4）-TCP性能问题的原因？" class="headerlink" title="4） TCP性能问题的原因？"></a>4） TCP性能问题的原因？</h3><ol>
<li><strong>TCP 的拥塞控制在发生丢包时会进行退让，减少能够发送的数据段数量，但是丢包并不一定意味着网络拥塞，更多的可能是网络状况较差；</strong></li>
<li><strong>TCP 的三次握手带来了额外开销，这些开销不只包括需要传输更多的数据，还增加了首次传输数据的网络延迟；</strong></li>
<li><strong>TCP 的重传机制在数据包丢失时可能会重新传输已经成功接收的数据段，造成带宽的浪费；</strong></li>
</ol>
<h3 id="5）Http-1-0和Http-1-1区别？"><a href="#5）Http-1-0和Http-1-1区别？" class="headerlink" title="5）Http 1.0和Http 1.1区别？"></a>5）<strong>Http 1.0和Http 1.1区别？</strong></h3><ol>
<li><p><strong>长连接</strong> <strong>：</strong>在HTTP/1.0中，默认使用的是短连接，也就是说每次请求都要重新建立一次连接。</p>
<p>HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。HTTP 1.1起，默认使用长连接 ，默认开启Connection： keep-alive。 HTTP/1.1的持续连接有<strong>非流水线方式</strong>和<strong>流水线方式</strong> 。</p>
<p>流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</p>
</li>
<li><p><strong>错误状态响应码</strong> <strong>：</strong>在HTTP1.1中新增了24个错误状态响应码，如：</p>
<p><strong>409（Conflict）表示请求的资源与资源的当前状态发生冲突</strong>；</p>
<p><strong>410（Gone）表示服务器上的某个资源被永久性的删除。</strong></p>
</li>
<li><p><strong>缓存处理</strong> <strong>：\</strong>在HTTP1.0中主要使用header里的*<em>If-Modified-Since，Expires*</em>来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如<strong>Entity tag，If-Unmodified-Since，If-Match，If-None-Match</strong>等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>带宽优化及网络连接的使用</strong> <strong>：</strong>``HTTP 1.0<code>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了</code>range头域`，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
</ol>
<h3 id="6）浏览器中输入url到显示主页的过程？"><a href="#6）浏览器中输入url到显示主页的过程？" class="headerlink" title="6）浏览器中输入url到显示主页的过程？"></a>6）<strong>浏览器中输入url到显示主页的过程？</strong></h3><h3 id="7）Cookie和Session区别？"><a href="#7）Cookie和Session区别？" class="headerlink" title="7）Cookie和Session区别？"></a>7）Cookie和Session区别？</h3><h3 id="8）Http1-0和Http1-1区别？"><a href="#8）Http1-0和Http1-1区别？" class="headerlink" title="8）Http1.0和Http1.1区别？"></a>8）Http1.0和Http1.1区别？</h3><h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/111375294" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/111375294</a></p>
</blockquote>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>为了加速浏览，把已经请求过的资源拷贝一份存储起来，当下次需要使用这份资源时，浏览器会根据缓存机制会判断是否向服务器重新请求。</p>
<h2 id="缓存分类"><a href="#缓存分类" class="headerlink" title="缓存分类"></a>缓存分类</h2><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>也就是内存中的缓存。</p>
<p><code>Memory Cache</code>优点是读取速度快，但是缓存会随着进程的释放而释放。</p>
<p>当用户关闭页面时，<code>Memory Cache</code>也会随之被清空。</p>
<h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>也就是硬盘中的缓存。</p>
<p>它会根据 HTTP头字段去做判断，即使你关闭了页面，当下次打开时，如果判定缓存命中，浏览器仍然可以从硬盘中读取缓存，它解决了内存缓存的小和无法持续缓存的缺点，但是也因此相对较慢。</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200721154105075.png" alt="image-20200721154105075"></p>
<h2 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h2><p>浏览器请求资源前会<strong>先判断是否命中==强制缓存==</strong>，再判断<strong>是否命中==协商缓存==</strong>。</p>
<p>两者的根本区别在于<strong>是否需要再次向服务器发送请求。</strong></p>
<h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a><strong>强制缓存</strong></h3><p>强缓存就是不通过服务器端来判断，利用http头中的<strong><code>Expires</code></strong>和<strong><code>Cache-Control</code></strong>两个字段来判断本地缓存的资源是否有效。</p>
<h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>这个字段出现在<code>HTTP/1.0</code>时期，该字段表示<strong>缓存到期时间</strong>，这个时间<strong>代表着这个资源的失效时间（需要的缓存时长+服务器时间）</strong>。</p>
<p>在此时间之前所有的请求都算命中缓存。</p>
<p><strong>缺点</strong>：就是无法保证客户端时间和服务端时间是一致的。也就说可能因为客户端时间问题导致缓存出现问题。</p>
<h4 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h4><p>在<code>HTTP/1.1</code>中新增加了一个字段<code>Cache-Control</code>，相对于<code>Expires</code>的绝对时间，<code>Cache-Control</code>中<code>max-age</code>采用的是<strong>相对时间</strong>，即使客户端时间发生改变，相对时间也不会随之改变，这样可以<strong>保持服务器和客户端的时间一致性。</strong></p>
<p>因此在<code>HTTP/1.1</code>推广后<code>Expires</code>已经渐渐被取代，而当<code>max-age</code>和<code>Expires</code>同时存在，<strong>前者优先级高于后者</strong>。</p>
<h4 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a>no-cache</h4><p>如果头字段中含有<code>Pragma:no-cache,Cache-Control:no-cache</code>或者<code>Cache-Control:no-store</code>。则代表不会命中强缓存。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强缓存未命中是，就会进入协商缓存阶段，此时客户端会向服务端请求，由服务端来来决定本地缓存资源是否可用。</p>
<h4 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a><strong><code>Last-Modified</code>和<code>If-Modified-Since</code></strong></h4><p>当浏览器<strong>第一次</strong>请求资源时，服务器返回的头字段（response-header）中会包含<code>Last-Modify</code>字段，表示当时该资源最后的修改时间，是一个绝对时间。</p>
<p>当<strong>第二次</strong>需要该资源时，会向服务端发送的请求头中包含<code>If-Modify-Since</code>字段，值为缓存之前返回的<code>Last-Modify</code>。</p>
<p>服务端会根据收到的<code>If-Modify-Since</code>和当前的<code>Last-Modified</code>进行比较，如果<strong>命中缓存</strong>，则返回<strong>304</strong>，客户端使用缓存，如果不同则下载正确的数据。</p>
<h4 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a><strong><code>ETag</code>和<code>If-None-Match</code></strong></h4><p>由于一些文件也许会周期性的更改，但是他的内容并不改变，这个时候希望能够命中缓存。</p>
<p>为了解决这个问题<code>ETag</code>和<code>If-None-Match</code>出现了：</p>
<p><code>ETag</code>是一串可以<strong>代表该文件唯一的字符串</strong>，是<strong>通过对文件的某些值组合hash后的一个值</strong>，当客户端发现和服务器约定的直接读取缓存的时间过了（一般是<code>Cache-Control</code>的<code>max-age</code>），就在请求中发送<code>If-None-Match</code>选项，值即为上次请求后响应头的<code>ETag</code>值，该值在服务端和服务端代表该文件唯一的字符串对比（如果服务端该文件改变了，该值就会变），如果相同，则返回<code>304</code>，客户端使用缓存，如果不同则下载正确的数据。</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200721155155665.png" alt="image-20200721155155665"></p>
<h2 id="用户行为对缓存影响？"><a href="#用户行为对缓存影响？" class="headerlink" title="用户行为对缓存影响？"></a>用户行为对缓存影响？</h2><p>1）当<strong>强制刷新网页</strong>时，直接从服务器加载，跳过强缓存和协商缓存；</p>
<p>2）当<strong>刷新网页</strong>时，跳过强制缓存，但是会检查协商缓存；</p>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2020/06/23/Redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>PREV</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">2020-06-23</span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签 | tags"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="查看 计算机网络 标签">
                        <b>#</b> 计算机网络
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2020/07/23/hello-world/" target="_self">
                <span>NEXT</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div class="post-catalog" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#网络层级"><span class="toc-text">网络层级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IP"><span class="toc-text">IP</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP、UDP"><span class="toc-text">TCP、UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#报文头部"><span class="toc-text">报文头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手（客户端触发）"><span class="toc-text">三次握手（客户端触发）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么是三次握手？不是两次、四次？"><span class="toc-text">为什么是三次握手？不是两次、四次？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四次挥手（客户端-服务端触发）"><span class="toc-text">四次挥手（客户端&#x2F;服务端触发）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要四次挥手"><span class="toc-text">为什么要四次挥手?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP拥塞控制"><span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-慢开始和拥塞避免"><span class="toc-text">1. 慢开始和拥塞避免</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#慢开始算法"><span class="toc-text">慢开始算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#拥塞避免"><span class="toc-text">拥塞避免</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-快重传和快恢复"><span class="toc-text">2. 快重传和快恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDOS攻击"><span class="toc-text">DDOS攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SYN攻击"><span class="toc-text">SYN攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#避免SYN攻击"><span class="toc-text">避免SYN攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-避免-SYN-攻击方式一"><span class="toc-text">1. *避免 SYN 攻击方式一***</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-避免SYN攻击方式二"><span class="toc-text">2. 避免SYN攻击方式二\</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#粘包"><span class="toc-text">粘包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是TCP粘包？"><span class="toc-text">什么是TCP粘包？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#造成粘包原因？"><span class="toc-text">造成粘包原因？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#（1）发送方原因"><span class="toc-text">（1）发送方原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（2）接收方原因"><span class="toc-text">（2）接收方原因</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#什么时候处理粘包现象？"><span class="toc-text">什么时候处理粘包现象？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#如何处理粘包现象？"><span class="toc-text">如何处理粘包现象？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（1）发送方"><span class="toc-text">（1）发送方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（2）接收方"><span class="toc-text">（2）接收方</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#（2）应用层"><span class="toc-text">（2）应用层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP会不会产生粘包问题？"><span class="toc-text">UDP会不会产生粘包问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么客户端最后还要等待2MSL？"><span class="toc-text">为什么客户端最后还要等待2MSL？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><span class="toc-text">为什么建立连接是三次握手，关闭连接确是四次挥手呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？"><span class="toc-text">如果已经建立了连接，但是客户端突然出现故障了怎么办？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP数据包的编号（SEQ）作用？"><span class="toc-text">TCP数据包的编号（SEQ）作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP如何保证可靠传输？"><span class="toc-text">TCP如何保证可靠传输？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）ARQ协议"><span class="toc-text">1）ARQ协议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#停止等待ARQ协议"><span class="toc-text">停止等待ARQ协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-无差错情况"><span class="toc-text">1) 无差错情况:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-出现差错情况（超时重传）"><span class="toc-text">2) 出现差错情况（超时重传）:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-确认丢失和确认迟到"><span class="toc-text">3) 确认丢失和确认迟到</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#连续ARQ协议"><span class="toc-text">连续ARQ协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）滑动窗口和流量控制"><span class="toc-text">2）滑动窗口和流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3）拥塞控制"><span class="toc-text">3）拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP短连接"><span class="toc-text">TCP短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP长连接"><span class="toc-text">TCP长连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#长连接短链接优缺点？"><span class="toc-text">长连接短链接优缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP协议和UDP协议的区别是什么"><span class="toc-text">TCP协议和UDP协议的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-和-UDP-应用场景"><span class="toc-text">TCP 和 UDP 应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QUIC"><span class="toc-text">QUIC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP协议"><span class="toc-text">HTTP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS协议"><span class="toc-text">HTTPS协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#断点续传"><span class="toc-text">断点续传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Q-amp-A"><span class="toc-text">Q&amp;A</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1）-一个-IP-的服务器监听了一个端口，它的-TCP-的最大连接数是多少？"><span class="toc-text">1） 一个 IP 的服务器监听了一个端口，它的 TCP 的最大连接数是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2）-为什么-UDP-头部没有「首部长度」字段，而-TCP-头部有「首部长度」字段呢？"><span class="toc-text">2） 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3）-为什么-UDP-头部有「包长度」字段，而-TCP-头部则没有「包长度」字段呢？"><span class="toc-text">3） 为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4）-TCP性能问题的原因？"><span class="toc-text">4） TCP性能问题的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5）Http-1-0和Http-1-1区别？"><span class="toc-text">5）Http 1.0和Http 1.1区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6）浏览器中输入url到显示主页的过程？"><span class="toc-text">6）浏览器中输入url到显示主页的过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7）Cookie和Session区别？"><span class="toc-text">7）Cookie和Session区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8）Http1-0和Http1-1区别？"><span class="toc-text">8）Http1.0和Http1.1区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浏览器缓存"><span class="toc-text">浏览器缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#作用"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存分类"><span class="toc-text">缓存分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-Cache"><span class="toc-text">Memory Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Disk-Cache"><span class="toc-text">Disk Cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存策略"><span class="toc-text">缓存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#强制缓存"><span class="toc-text">强制缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Expires"><span class="toc-text">Expires</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Cache-Control"><span class="toc-text">Cache-Control</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#no-cache"><span class="toc-text">no-cache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协商缓存"><span class="toc-text">协商缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Last-Modified和If-Modified-Since"><span class="toc-text">Last-Modified和If-Modified-Since</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ETag和If-None-Match"><span class="toc-text">ETag和If-None-Match</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用户行为对缓存影响？"><span class="toc-text">用户行为对缓存影响？</span></a></li></ol></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        


  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <div id="vcomments"></div>

  <script>
    new Valine({
      el: '#vcomments',
      appId: 'bSYdbCIyQHwCwv9NC9Fes7mU-gzGzoHsz',
      appKey: 'zuj9HNh3w0O1O5t1nR1yeNHD',
      placeholder: '说出你的想法...',
      avatar: 'retro'
    })
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>

  
        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="https://github.com/YYZ-coder" target="_blank" rel="noopener">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      <a href="">Copyright © YYZ-coder 2020</a>
    </div>
  
    <div class="footer-more">
      <a href="https://github.com/zchengsite/hexo-theme-oranges" target="_blank" rel="noopener">Theme by Oranges | Powered by Hexo</a>
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



    </div>
  </body>
</html>
