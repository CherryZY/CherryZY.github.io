<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="author" content="zchengsite, 1451426471@qq.com" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  
  <title>面试官：说下AQS原理？以及ReentrantLock？ | coder的特殊身份</title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

<meta name="generator" content="Hexo 4.2.1"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/"><img src="/images/avatar.png" alt=""></a>
    <div class="nickname"><a href="/"></a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">分类</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  
  
  
  
  
  
  
  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">面试官：说下AQS原理？以及ReentrantLock？</div>
      <div class="post-attach">
        <span class="post-pubtime">2020-07-22</span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签 | tags"></i>
                
                <span class="span--tag">
                  <a href="/tags/%E9%9D%A2%E8%AF%95/" title="查看 面试 标签">
                    <b>#</b> 面试
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/java/" title="查看 java 标签">
                    <b>#</b> java
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%B9%B6%E5%8F%91/" title="查看 并发 标签">
                    <b>#</b> 并发
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>队列同步器 AQS主要是依赖于内部的一个 <code>FIFO（first-in-first-out）</code>双向队列来对同步状态进行管理的，当线程获取同步状态失败时，同步器会将当前线程和当前等待状态等信息封装成一个内部定义的节点 Node，然后将其加入队列，同时阻塞当前线程（<code>unsafe.park()</code>）；</p>
<p>当同步状态释放时，会将同步队列中首节点唤醒，让其再次尝试去获取同步状态。</p>
<p>核心：<strong><code>CLH</code>双向链表 + Node</strong></p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/anlian523/article/details/106598910" target="_blank" rel="noopener">https://blog.csdn.net/anlian523/article/details/106598910</a></p>
</blockquote>
<h3 id="AbstractQueueSynchronizer"><a href="#AbstractQueueSynchronizer" class="headerlink" title="AbstractQueueSynchronizer"></a><code>AbstractQueueSynchronizer</code></h3><h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The synchronization state.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Head of the wait queue, lazily initialized.  Except for</span></span><br><span class="line"><span class="comment">    * initialization, it is modified only via method setHead.  Note:</span></span><br><span class="line"><span class="comment">    * If head exists, its waitStatus is guaranteed not to be</span></span><br><span class="line"><span class="comment">    * CANCELLED.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tail of the wait queue, lazily initialized.  Modified only via</span></span><br><span class="line"><span class="comment">    * method enq to add new wait node.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure>

<h5 id="Node"><a href="#Node" class="headerlink" title="Node"></a><strong>Node</strong></h5><p>用来存储阻塞的任务，一个虚拟双端队列（<code>CLH</code>）节点，队列遵循FIFO原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">				<span class="comment">// 双向链表的结构</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">				<span class="comment">// Node对象用来包装线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">				<span class="comment">// 用来表明当前node的线程是想要获取共享锁还是独占锁</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>主要作用：</strong></p>
<p>用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果已经被占用，那么当前线程就会被构造成一个<code>Node节点</code>加入到同步队列的尾部，队列的头节点是成功获取锁的节点，当头节点线程释放锁时，会唤醒后面的节点并释放当前头节点的引用。</p>
<p><strong>主要属性：</strong></p>
<img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712200326867.png?ynotemdtimestamp=1593654556079" alt="image-20200712200326867" style="zoom: 33%;" />

<h5 id="State"><a href="#State" class="headerlink" title="State"></a><strong>State</strong></h5><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712200119989.png" alt="image-20200712200119989" style="zoom:50%;" />

<p>用来标识当前锁状态：</p>
<ul>
<li>共享锁：<code>state</code>为0则无锁，为N则表示当前有N个线程已获取锁；</li>
<li>独占锁：<code>state</code>为0则无锁，为1则表示锁已被自己/别的线程获取，倘若锁重入，则可以<code>state++</code>；</li>
</ul>
<h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><blockquote>
<p>参考：<a href="https://blog.csdn.net/anlian523/article/details/106344926" target="_blank" rel="noopener">AQS深入理解系列（一） 独占锁的获取过程</a></p>
</blockquote>
<h5 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment"> * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment"> * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment"> * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment"> * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment"> *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment"> *        can represent anything you like.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// 使用enq的快捷方法，如果CAS操作失败，才会去执行enq </span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="comment">// 如果队列不为空</span></span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 执行到这里，有两种情况：</span></span><br><span class="line">       <span class="comment">// 1.队列为空。head和tail成员从来没有初始化过</span></span><br><span class="line">       <span class="comment">// 2.CAS操作失败。当执行compareAndSetTail时，tail成员已经被修改了</span></span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712202502157.png?ynotemdtimestamp=1593654556079" alt="image-20200712202502157"></p>
<h6 id="1、首先执行tryAcquire进行尝试获取锁；"><a href="#1、首先执行tryAcquire进行尝试获取锁；" class="headerlink" title="1、首先执行tryAcquire进行尝试获取锁；"></a>1、首先执行<code>tryAcquire</code>进行尝试获取锁；</h6><h6 id="2、第1步失败，addWaiter将当前线程节点（Node-EXCLUSIVE）放入链表尾部，并返回Node；"><a href="#2、第1步失败，addWaiter将当前线程节点（Node-EXCLUSIVE）放入链表尾部，并返回Node；" class="headerlink" title="2、第1步失败，addWaiter将当前线程节点（Node.EXCLUSIVE）放入链表尾部，并返回Node；"></a>2、第1步失败，<code>addWaiter</code>将当前线程节点（<code>Node.EXCLUSIVE</code>）放入链表尾部，并返回<code>Node</code>；</h6><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200712202634349.png" alt="image-20200712202634349" style="zoom:50%;" />

<p><strong>addWaiter</strong>步骤：</p>
<ol>
<li>通过<code>当前线程（Thread.currentThread()）</code>和<code>Node.EXCLUSIVE</code>新建一个Node对象；</li>
<li>获取当前<code>尾节点</code>（<code>tail节点</code>）（<code>Node pred = tail;</code>）；</li>
<li>倘若<code>pred</code>不为<code>null</code>，则将<code>node</code>的<code>prev</code>指向<code>pred</code>，然后<strong>CAS</strong>设置当前<code>node</code>节点为<code>tail</code>节点（==这个方法主要是对<code>tailOffset</code>和<code>Expect</code>进行比较，如果<code>tailOffset</code>的<code>Node</code>和<code>Expect</code>的<code>Node</code>地址是相同的，那么设置Tail的值为Update的值。==），成功则将<code>pred.next = node;</code></li>
<li>上述不成功则执行<code>enq()</code>方法进行操作；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 如果tail为null，说明队列为空，head肯定也为null</span></span><br><span class="line">        <span class="comment">// 进一步说明 等待队列的初始化是懒汉式的</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        <span class="comment">// 如果tail不为null，说明队列至少有一个dummy node，head肯定也不为null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>enq</code></strong>步骤（<code>for(;;)</code>循环）：</p>
<ol>
<li>获取当前队列尾节点（<code>Node t = tail</code>）；</li>
<li>倘若<code>tail == null</code>，设置一个<code>dummy头节点</code>（<code>compareAndSetHead(new Node())</code>），并且<code>tail = head</code>，然后再进行下一次循环，设置当前节点；</li>
<li>2反之，则设置当前节点的prev为tail（<code>node.prev = t;</code>），开始用CAS设置尾节点（<code>compareAndSetTail(t, node)</code>），成功则设置<code>tail</code>的<code>next</code>为<code>node</code>（<code>t.next = node;</code>），反之继续循环；</li>
</ol>
<p><strong>==这里是个自旋CAS操作；==</strong></p>
<p>因为<code>CAS</code>操作的保证，所有线程都能够执行第A步（<code>node.prev = t</code>）， 但第B、C步（<code>comareAndSetTailxxx</code>、<code>t.next = node</code>）只会有一个线程能够执行到。</p>
<p>一个<code>node</code>新建的时候，它的<code>waitStatus</code>是默认初始化为0。</p>
<p><strong><code>enq</code>的尾分叉</strong>：</p>
<p>从上面的步骤可以看出，如果存在很多个线程都刚好执行到了 <code>node.prev = t</code> 这里，那么<code>CAS</code>失败的线程不能成功入队，此时它们的<code>prev</code>还暂时指向的旧tail。</p>
<p><strong><code>prev</code>的有效性</strong>：</p>
<p>从上图第二步可以看到，此时<code>线程1</code>的node已经是成功放到队尾了，但此时队列却处于一个中间状态，前一个node的next还没有指向队尾呢。此时，如果另一个线程如果通过next指针遍历队列，就会漏掉最后那个node；但如果另一个线程通过tail成员的<code>prev</code>指针遍历队列，就不会漏掉node了。</p>
<h6 id="3、调用acquireQueued，传入新增的Node；"><a href="#3、调用acquireQueued，传入新增的Node；" class="headerlink" title="3、调用acquireQueued，传入新增的Node；"></a>3、调用<code>acquireQueued</code>，传入新增的<code>Node</code>；</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 默认非公平锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="comment">// 尝试获取锁的前提是node是head的后继</span></span><br><span class="line">              <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                  failed = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> interrupted;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 执行到这里，说明</span></span><br><span class="line">              <span class="comment">// 要么 node.predecessor()不是head节点</span></span><br><span class="line">              <span class="comment">// 要么 尝试获取锁失败了（tryAcquire()）</span></span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>acquireQueued()</code></strong>步骤：</p>
<p><code>addWaiter</code>倘若链表为空，初始化链表哨兵节点，并且将当前<code>Node</code>放到<code>tail尾部</code>（<code>for(;;)</code>死循环）。（此时链表两个节点）；调用<code>acquireQueued</code>，操作当前线程归属的Node。 </p>
<ol start="0">
<li><p>初始化失败状态（<code>boolean failed = true;</code>）和中断状态（<code>boolean interrupted = false;</code>）；</p>
</li>
<li><p>进入<code>for(;;)</code>，判断当前节点的前置节点是否为头结点；</p>
<ul>
<li><p>是，继续调用<code>tryAcquire</code>尝试获取锁； 获取成功，回收链表初始化节点，将当前线程节点置链表首部，然后直接返回中断状态<code>interrupted</code>；</p>
</li>
<li><p>否，或获取失败，<code>shouldParkAfterFailedAcquire</code>判断<code>prev节点</code>的<code>waitStatus</code>是否为<code>SIGNAL</code>：</p>
<p><strong>是</strong>则执行<code>UnSafe.park()</code>执行挂起操作，然后执行<code>interrput</code>中断操作；</p>
<p><strong>不是</strong>的话，若为<code>CANCEL状态</code>，则跳过往后寻找，若也不是<code>CANCEL状态</code>，则设置前驱节点为<code>SIGNAL</code>。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>倘若为可中断获取，则在<code>parkAndCheckInterrupt</code>中判断确实线程已经中断，则抛异常；</strong></li>
<li><strong>倘若不为可中断获取，则假设<code>parkAndCheckInterrupt</code>中判断线程已经中断，正常返回。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点已经设置了SIGNAL，闹钟已经设好，现在我可以安心睡觉（阻塞）了。</span></span><br><span class="line"><span class="comment">         * 如果前驱变成了head，并且head的代表线程exclusiveOwnerThread释放了锁，</span></span><br><span class="line"><span class="comment">         * 就会来根据这个SIGNAL来唤醒自己</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 发现传入的前驱的状态大于0，即CANCELLED。说明前驱节点已经因为超时或响应了中断，</span></span><br><span class="line"><span class="comment">         * 而取消了自己。所以需要跨越掉这些CANCELLED节点，直到找到一个&lt;=0的节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 进入这个分支，ws只能是0或PROPAGATE。</span></span><br><span class="line"><span class="comment">         * CAS设置ws为SIGNAL</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>shouldParkAfterFailedAcquire</code>函数在<code>acquireQueued</code>的调用中处于一个死循环中，且因为<code>shouldParkAfterFailedAcquire</code>函数若返回false，且考虑当前线程一直不能获取到锁的情况，那么此函数必将至少执行两次才能阻塞自己。</p>
<p><strong><code>shouldParkAfterFailedAcquire</code>只有在检测到前驱的状态为<code>SIGNAL</code>才能返回true，只有true才会执行到<code>parkAndCheckInterrupt</code>。</strong></p>
<p><strong><code>shouldParkAfterFailedAcquire</code>返回false后，进入下一次循环，当前线程又会再次尝试获取锁（<code>p == head &amp;&amp; tryAcquire(arg)</code>）。</strong></p>
<p>或者说，每次执行<code>shouldParkAfterFailedAcquire</code>，都说明当前循环 尝试过获取锁了，但失败了。</p>
<p>如果刚开始前驱的状态为0，那么需要第一次执行<code>compareAndSetWaitStatus(pred, ws, Node.SIGNAL)</code>返回false并进入下一次循环，第二次才能进入<code>if (ws == Node.SIGNAL)</code>分支，所以说 至少执行两次。<br>死循环保证了最终一定能设置前驱为<code>SIGNAL</code>成功的。（考虑当前线程一直不能获取到锁）</p>
<p><strong><code>shouldParkAfterFailedAcquire</code>执行流程：</strong></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200719165934505.png" alt="image-20200719165934505"></p>
<p><strong><code>node</code>一共有四种状态，但在独占锁的获取和释放过程中，我们只可能将<code>node</code>的状态变成<code>CANCELLED</code>或<code>SIGNAL</code>，而<code>shouldParkAfterFailedAcquire</code>函数就会把一个node的状态变成<code>SIGNAL</code>。</strong></p>
<p><strong>注意，一个node新建的时候，它的<code>waitStatus</code>是默认初始化为0的。</strong></p>
<ul>
<li><strong><code>CANCELLED</code>，一个node的状态是<code>CANCELLED</code>，说明这个node的代表线程已经取消等待了。</strong></li>
<li><strong><code>SIGNAL</code>，一个node的状态是<code>SIGNAL</code>，说明这个node的后继node的代表线程已经阻塞或马上阻塞（<code>shouldParkAfterFailedAcquire</code>设置前驱为<code>SIGNAL</code>后，下一次的<code>acquireQueued</code>循环可能就会阻塞了，所以说“已经阻塞或马上阻塞”），并且当前node成为head并释放锁时，会根据<code>SIGNAL</code>来唤醒后继node。即<code>SIGNAL</code>是唤醒后继节点的标志。</strong></li>
</ul>
<p>==<strong><code>CANCELLED</code>状态与当前node关联，<code>SIGNAL</code>状态与后继node关联。</strong>==</p>
<h6 id="为什么要有哨兵节点？"><a href="#为什么要有哨兵节点？" class="headerlink" title="为什么要有哨兵节点？"></a>为什么要有哨兵节点？</h6><p>解决边界问题，如果没有边界，指定环节，按照同样算法可能会在边界处发生异常。</p>
<h6 id="4、第二步中acquireQueued返回中断状态为true，则Thread-currentThread-interrupt"><a href="#4、第二步中acquireQueued返回中断状态为true，则Thread-currentThread-interrupt" class="headerlink" title="4、第二步中acquireQueued返回中断状态为true，则Thread.currentThread().interrupt();"></a>4、第二步中<code>acquireQueued</code>返回中断状态为true，则<code>Thread.currentThread().interrupt()</code>;</h6><p>整体流程：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200719160110977.png" alt="image-20200719160110977"></p>
<ol>
<li>首先<code>tryAqurie</code>获取锁；</li>
<li>获取锁失败，则准备将当前线程Node添加到队列末端；（<code>CAS</code>）</li>
<li>倘若第一个线程，这时首节点为<code>null</code>，则初始化一个默认<code>Node</code>作为头结点，然后将当前线程<code>Node</code>添加到头结点尾部，失败则循环设置<code>CAS</code>；</li>
<li>倘若不为第一个线程，则进入<code>for(;;)</code>循环设置尾节点CAS；</li>
<li>然后得到当前节点开始获取锁：<ul>
<li>首先获取当前节点的前置节点（在双向链表中，第一个节点并不存储线程，只是虚节点，从第二个开始存储线程信息），并且成功获取锁，将当前线程节点设置为头结点；</li>
<li>未成功获取锁，或者前置节点不为头结点，则判断当前接口是否需要被阻塞（防止长时间自旋给cpu造成执行开销，浪费资源）。</li>
<li>如果当前节点前置节点为<code>SIGNAL</code>，表示前置节点线程正在等待释放，且当前线程节点等待线程释放，可以阻塞，则阻塞。</li>
<li>如果当前节点前置节点为<code>CANCEL</code>，表示被取消了，则将当前前置节点的前置节点设为当前线程节点的前置节点，且不可中断，首先循环获取有效前置节点，然后继续循环获取锁。</li>
<li>如果当前线程节点为<code>PROPAGATE</code>或者<code>默认值0</code>，则将当前节点的前置节点设置为<code>SIGNAL</code>，不可中断，继续循环获取锁。</li>
</ul>
</li>
</ol>
<h5 id="CANCEL节点如何生成？"><a href="#CANCEL节点如何生成？" class="headerlink" title="CANCEL节点如何生成？"></a>CANCEL节点如何生成？</h5><p>在<code>acquireQueued</code>方法中的<code>cancelAcquire</code>中将其<code>node</code>设置为<code>CANCEL</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">          ...</span><br><span class="line">          failed = <span class="keyword">false</span>;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Ignore if node doesn't exist（过滤无效节点）</span></span><br><span class="line">      <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      node.thread = <span class="keyword">null</span>;<span class="comment">// 设置当前节点关联线程为null</span></span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 将当前node的前置节点设置为非CANCEL状态节点。</span></span><br><span class="line">      <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">      Node pred = node.prev;</span><br><span class="line">      <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">          node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">      <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">      <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    	<span class="comment">// </span></span><br><span class="line">    	<span class="comment">// 获取过滤后的前驱节点的后继结点。</span></span><br><span class="line">      Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">      <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">      <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    	<span class="comment">// 将当前节点waitStatus取消状态</span></span><br><span class="line">      node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    	<span class="comment">// 倘若当前节点为尾节点，且CAS设置tail为前置节点成功，则设置pred的next节点为null</span></span><br><span class="line">      <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">          compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">          <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        </span><br><span class="line">        	<span class="comment">// 如果前置节点不是head：</span></span><br><span class="line">        	<span class="comment">// 1、判断当前节点前驱节点是否为SIGNAL；</span></span><br><span class="line">        	<span class="comment">// 2、将当前不为CANCEL状态的前置节点设置为SIGNAL；</span></span><br><span class="line">        	<span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null，</span></span><br><span class="line">		    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点。</span></span><br><span class="line">          <span class="keyword">int</span> ws;</span><br><span class="line">          <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">              ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">               (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">              pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node next = node.next;</span><br><span class="line">              <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                  compareAndSetNext(pred, predNext, next);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              unparkSuccessor(node);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          node.next = node; <span class="comment">// help GC</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>cancelAcquire</code>步骤：</strong></p>
<ol>
<li><p>获取当前节点的前驱节点。</p>
<ul>
<li>倘若前驱节点的状态是<code>CANCEL</code>，那就一直遍历，直到前驱节点不为<code>CANCEL</code>，同时赋值给<code>node.prev = pred;</code></li>
<li>将当前<code>node</code>设置为<code>CANCEL</code>状态；</li>
</ul>
</li>
<li><p>根据当前节点状态，需要考虑以下情况：</p>
<ul>
<li><p>当前节点是尾节点：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200719233115203.png" alt="image-20200719233115203"></p>
</li>
<li><p>当前节点是Head的后继节点：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200719233131979.png" alt="image-20200719233131979"></p>
</li>
<li><p>当前节点不是Head的后继节点，也不是尾节点：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200719233201578.png" alt="image-20200719233201578"></p>
</li>
</ul>
</li>
</ol>
<p>   <strong>为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</strong></p>
<p>   执行<code>cancelAcquire</code>的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过<code>Try</code>代码块中的<code>shouldParkAfterFailedAcquire</code>方法了），如果此时修改<code>Prev指针</code>，有可能会导致<code>Prev</code>指向另一个已经移除队列的<code>Node</code>，因此这块变化<code>Prev指针</code>不安全。</p>
<pre><code>`shouldParkAfterFailedAcquire`方法中，会执行下面的代码，其实就是在处理`Prev指针`：</code></pre>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在AbstractQueueSynchronizer.shouldParkAfterFailedAcquire中</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// 循环向前查找取消节点，把取消节点从队列中剔除</span></span><br><span class="line">		node.prev = pred = pred.prev;</span><br><span class="line">	&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>   <code>shouldParkAfterFailedAcquire</code>是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更<code>Prev指针</code>比较安全。</p>
<h5 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">   * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">   * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">   *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">   *        can represent anything you like.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取头结点waitStatus</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">      compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取当前节点的下一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// 就从尾部节点开始找，到队首，找到队列第一个waitStatus&lt;0的节点。</span></span><br><span class="line">      <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">          s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前节点的下个节点不为空，而且状态&lt;=0，就把当前节点unpark</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      LockSupport.unpark(s.thread);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>ReentrantLock</code>中，Sync实现的<code>tryRelease</code>方法：</p>
<p>消除state值，解除<code>exclusiveOwnerThread</code>，<code>LockSupport.unpark()</code>解除当前线程挂起。</p>
<p>子类<code>tryRelease</code>成功后，开始执行<code>AQS.unparkSuccessor()</code>方法，唤醒头节点的后继节点，若为<code>CANCEL</code>，则从尾部到头部进行查找。</p>
<p><strong>流程图</strong>：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200720005147869.png" alt="image-20200720005147869"></p>
<h6 id="为什么从尾部往前查找？"><a href="#为什么从尾部往前查找？" class="headerlink" title="为什么从尾部往前查找？"></a>为什么从尾部往前查找？</h6><p>1、节点入队并不是原子操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.prev = pred; </span><br><span class="line">compareAndSetTail(pred, node)</span><br></pre></td></tr></table></figure>

<p>这两个地方可以看作是尾节点入队的原子操作，如果此时代码还没执行到 <code>pred.next = node;</code><br>这时又恰巧执行了<code>unparkSuccessor</code>方法，就没办法从前往后找了，因为后继指针还没有连接起来，所以需要从后往前找。</p>
<p>2、产生 <code>CANCELLED 状态</code>节点的时候，先断开的是 <code>Next 指针</code>，<code>Prev指针</code>并未断开，因此这也是必须要从后往前遍历才能够遍历完全部的<code>Node</code>。</p>
<p>3、倘若从为单向链表，从头部开始遍历链表的话，若此时头部出现竞争，则会导致获取不到next节点。</p>
<h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><blockquote>
<p>参考：<a href="https://blog.csdn.net/anlian523/article/details/106448512" target="_blank" rel="noopener">https://blog.csdn.net/anlian523/article/details/106448512</a></p>
<p><code>setHeadAndPropagate()</code> ：<a href="https://blog.csdn.net/anlian523/article/details/106319294" target="_blank" rel="noopener">https://blog.csdn.net/anlian523/article/details/106319294</a></p>
</blockquote>
<h5 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h5><blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/anlian523/article/details/106598739" target="_blank" rel="noopener">AQS深入理解系列（三）共享锁的获取与释放</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">   * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">   * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">   * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">   * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">   *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">   *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">          doAcquireShared(arg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">      <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">              <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                  <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                  <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                      setHeadAndPropagate(node, r);</span><br><span class="line">                      p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                      <span class="keyword">if</span> (interrupted)</span><br><span class="line">                          selfInterrupt();</span><br><span class="line">                      failed = <span class="keyword">false</span>;</span><br><span class="line">                      <span class="keyword">return</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">   * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">   * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">      Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">      setHead(node);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">       *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">       *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">       *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">       *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">       *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">       * and</span></span><br><span class="line"><span class="comment">       *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">       *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">       * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">       * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">       * anyway.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">          (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          Node s = node.next;</span><br><span class="line">          <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">              doReleaseShared();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>for循环的过程分析：</p>
<ol start="0">
<li><p>获取当前节点的前置节点；（<code>Node p = node.predecessor();</code>）</p>
</li>
<li><p>执行到<code>tryAcquireShared</code>后可能有两种情况：</p>
</li>
</ol>
<ul>
<li><p>如果<code>tryAcquireShared</code>的<code>返回值&gt;=0</code>，说明线程获取共享锁成功了，那么调用<code>setHeadAndPropagate</code>，然后函数即将返回。</p>
</li>
<li><p>如果<code>tryAcquireShared</code>的<code>返回值&lt;0</code>，说明线程获取共享锁失败了，那么调用<code>shouldParkAfterFailedAcquire</code>。</p>
<p>1、这个<code>shouldParkAfterFailedAcquire</code>一般来说，得至少执行两遍才能将返回true：</p>
<p>第一次<code>shouldParkAfterFailedAcquirenode</code>把前驱设置为<code>SIGNAL状态</code>，第二次检测到SIGNAL才返回true。</p>
<p>2、既然上一条说了，<code>shouldParkAfterFailedAcquirenode</code>一般执行两遍，那么很有可能第二遍的时候，发现自己的前驱突然变成head了并且获取共享锁成功，又或者本来第一遍的前驱就是head但第二遍获取共享锁成功了。不用觉得第一遍的SIGNAL白设置了，因为设置前驱SIGNAL本来就是为了让前驱唤醒自己的，现在自己处于醒着的状态就获得了共享锁，那就接着执行setHeadAndPropagate就好。</p>
<p>3、剩下的就是常见情况了。线程调用两次<code>shouldParkAfterFailedAcquire</code>，和一次<code>parkAndCheckInterrupt</code>后，便阻塞了。</p>
<p>之后就只能等待别人<code>unpark</code>自己了，以后如果自己唤醒了，又会走以上这个流程。</p>
</li>
</ul>
<h5 id="释放-1"><a href="#释放-1" class="headerlink" title="释放"></a>释放</h5><blockquote>
<p>参考：<a href="https://blog.csdn.net/anlian523/article/details/106515311" target="_blank" rel="noopener">AQS深入理解系列（二） 独占锁的释放过程</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">   * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">   *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">   *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">          doReleaseShared();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">          * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">          * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">          * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">          * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">          * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">          * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">          * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">          * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">          * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">              <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">              <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                      <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                  unparkSuccessor(h);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                          !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                  <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h4 id="可中断独占锁"><a href="#可中断独占锁" class="headerlink" title="可中断独占锁"></a>可中断独占锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock.java</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer.java</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">           doAcquireInterruptibly(arg);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><code>acquireInterruptibly</code>这个方法与 不响应中断的<code>acquire</code>方法 对应。同样的，进入这个方法后，会第一次进行<code>tryAcquire</code>尝试。但不同的，此<code>acquireInterruptibly</code>函数中，会去检测<code>Thread.interrupted()</code>，并抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 与acquireQueued方法类似</span></span><br><span class="line"><span class="comment">// 但是当执行parkAndCheckInterrupt()方法时，被挂起，之后唤醒当前线程后中断状态为True则抛异常，</span></span><br><span class="line"><span class="comment">// 并执行cancelAcquire将当前节点置为CANCEL状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>与<code>acquireQueued</code>的==区别==：</p>
<ul>
<li><p><code>doAcquireInterruptibly</code>没有返回值，而<code>acquireQueued</code>方法有返回值，代表当前线程是否被中断过。</p>
<ul>
<li><code>acquireQueued</code>方法需要有返回值，因为函数调用返回上层后，需要根据返回值来判断是否需要重新设置中断状态，在返回用户代码之前。</li>
<li><code>doAcquireInterruptibly</code>不需要返回值，因为该函数中如果检测到了中断状态，就直接抛出异常就好了。</li>
</ul>
</li>
<li><p><code>doAcquireInterruptibly</code>方法的<code>finally</code>块是可能会执行到<code>cancelAcquire(node)</code>的，而<code>acquireQueued</code>方法不可能去执行<code>cancelAcquire(node)</code>的。</p>
<p>在<code>doAcquireInterruptibly</code>方法中，如果线程阻塞在<code>parkAndCheckInterrupt</code>这里后，别的线程来中断阻塞线程，阻塞线程会被唤醒，然后抛出异常。</p>
<p>本来抛出异常该函数就马上结束掉的，但由于有<code>finally</code>块，所以在结束掉之前会去执行<code>finally</code>块，并且由于<code>failed</code>为true，则会执行<code>cancelAcquire(node)</code>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 避免空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  <span class="comment">// 循环用来跳过无效前驱</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    <span class="comment">// 执行完循环，pred会指向node的有效前驱。</span></span><br><span class="line">    <span class="comment">// 当然，如果node的前驱就是有效的。那么就不需要跳过了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pred的后继无论如何都需要取消，因为即使前面循环没有执行，</span></span><br><span class="line">    <span class="comment">// 现在pred的后继（肯定是参数node）也是一个马上取消掉的node。</span></span><br><span class="line">    <span class="comment">// 之后有些CAS操作会尝试修改pred的后继，如果CAS失败，那么说明有别的线程在做</span></span><br><span class="line">    <span class="comment">// 取消动作或通知动作，所以当前线程也不需要更多的动作了。</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里直接使用赋值操作，而不是CAS操作。</span></span><br><span class="line">    <span class="comment">// 如果别的线程在执行这步之后，别的线程将会跳过这个node。</span></span><br><span class="line">    <span class="comment">// 如果别的线程在执行这步之前，别的线程还是会将这个node当作有效节点。</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果node是队尾，那简单。直接设置pred为队尾，然后设置pred的后继为null</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 如果node不是队尾，node则有后继。</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>SIGNAL</code>设置成功，且<code>SIGNAL</code>都在node不是一个<code>dummy node</code>，那么将<code>pred</code>与<code>node</code>后继相连，让<code>node</code>后继继续安心睡觉（<code>park</code>）。</li>
<li>如果发现<code>node后继</code>已经是排队的第一个了、发现<code>SIGNAL</code>没有设置成功、发现<code>SIGNAL</code>设置成功但闹钟所在节点变空节点，都需要换线<code>node后继</code>。</li>
</ul>
<ol>
<li>将当前节点<code>node.waitStatus</code>设置为<code>CANCEL状态</code>，如果node是队尾，直接设置pred为队尾（<code>pred</code>的<code>waitStatus</code>必须为<code>SIGNAL</code>），<code>pred.next = null</code>，从而去除node。</li>
<li>倘若node不是队尾：<ol>
<li><code>pred == head</code>，且node不为尾节点，则将<code>pred</code>指向<code>node.next</code>；</li>
<li><code>pred != head</code>，且node不为尾节点，则执行<code>unparkSuccessor(node)</code>或者将<code>pred</code>与<code>node.next</code>相连接。</li>
</ol>
</li>
</ol>
<h4 id="超时可中断独占锁"><a href="#超时可中断独占锁" class="headerlink" title="超时可中断独占锁"></a>超时可中断独占锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock.java</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));<span class="comment">//第二个实参，换算得到nano</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer.java</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">           doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)<span class="comment">//如果时间小于0，直接返回失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;<span class="comment">//算出“死期”，当死期到了就直接返回失败了</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 看看你的年龄是否到达了死期</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)<span class="comment">//小于0，说明死期到了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)<span class="comment">//剩余寿命得大于1ms</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>doAcquireNanos</code>方法 与不响应中断的<code>acquireQueued</code>方法、响应中断的<code>doAcquireInterruptibly</code>方法进行对比，==区别==：</p>
<ul>
<li>每次循环都会检查时间<code>是否到达deadline</code>。</li>
<li>当剩余时间小于<code>spinForTimeoutThreshold</code>时，则不能调用<code>LockSupport.parkNanos</code>，因为时间太短，反而无法精确控制阻塞时间，所以不如在剩余的时间里一直循环。</li>
<li><code>LockSupport.parkNanos</code>除了会因为别人的<code>park</code>而唤醒，也会因为别人的中断而唤醒，当然最重要的，时间到了，它自己会唤醒。</li>
<li>不管哪种情况，被唤醒后，都会<strong>检查中断状态</strong>，每个循环都会检查一次。</li>
</ul>
<p><strong>流程图：</strong></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200720012138548.png" alt="image-20200720012138548"></p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a><code>Condition</code></h4><h5 id="await-加入条件等待队列"><a href="#await-加入条件等待队列" class="headerlink" title="await() 加入条件等待队列"></a><code>await()</code> 加入条件等待队列</h5><p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200713171739210.png" alt="image-20200713171739210"></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200713171758319.png" alt="image-20200713171758319"></p>
<p>1、新增<code>ConditionWaiter</code>节点，并放到队列尾部；</p>
<p>2、<code>fullyRelease</code>释放当前锁状态为0；</p>
<p>3、阻塞（<code>unsafe.park</code>挂起）直到发信号或被打断。</p>
<h5 id="signal-加入AQS等待队列"><a href="#signal-加入AQS等待队列" class="headerlink" title="signal() 加入AQS等待队列"></a><code>signal()</code> 加入<code>AQS</code>等待队列</h5><p>|<img src="http://qd2x6jysb.bkt.clouddn.com/image-20200713171930535.png" alt="image-20200713171930535">|<img src="http://qd2x6jysb.bkt.clouddn.com/image-20200713172059912.png" alt="image-20200713172059912" style="zoom:95%;" /></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200713172421534.png" alt="image-20200713172421534"></p>
<p>删除并转移节点，直到命中状态为不可取消或为null。 从信号中分离出来，部分鼓励编译器内联没有waiter节点的情况。</p>
<p>1、（<code>signal</code>）判断当前线程是否被持有（<code>exclusiveOwnerThread</code>）；</p>
<p>2、（<code>doSignal</code>）从头结点开始遍历，将当前节点的<code>Node.waitStates</code>修改为0，失败则返回false，继续循环取下一个节点。将当前节点<code>enq</code>到<code>AQS</code>同步队列。</p>
<p>判断当前节点前驱节点的<code>waitStates</code>，假如为CANCEL，或者将当前节点<code>waitStates</code>用CAS变为<code>Node.SIGNAL</code>（正在等待）失败，<br>则唤醒当前线程。（这里就是将<code>waitStates</code>的值0，<code>CAS</code>为-1）</p>
<h5 id="signal-加入AQS等待队列-1"><a href="#signal-加入AQS等待队列-1" class="headerlink" title="signal()  加入AQS等待队列"></a><code>signal()</code>  加入<code>AQS</code>等待队列</h5><p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200713171906787.png" alt="image-20200713171906787"></p>
<p>删除并转移所有节点。（唤醒，并让所有任务重新入队）</p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><code>ReentrantLock</code></h3><p><strong>Sync</strong>为<code>ReentrantLock</code>里面的一个内部类，它继承<code>AQS</code>（<code>AbstractQueuedSynchronizer</code>），它有两个子类：<code>公平锁FairSync</code>和<code>非公平锁NonfairSync</code>。</p>
<h4 id="非公平锁加锁（默认）"><a href="#非公平锁加锁（默认）" class="headerlink" title="非公平锁加锁（默认）"></a>非公平锁加锁（默认）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 类中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//尝试获取锁</span></span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">           setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="comment">//获取失败，调用AQS的acquire(int arg)方法</span></span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractQueueSynchronizer类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">               acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 类中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantLock.Sync中</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//当前线程</span></span><br><span class="line">       <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">       <span class="comment">//获取同步状态</span></span><br><span class="line">       <span class="keyword">int</span> c = getState();</span><br><span class="line">       <span class="comment">//state == 0,表示没有该锁处于空闲状态</span></span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//获取锁成功，设置为当前线程所有</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//线程重入</span></span><br><span class="line">       <span class="comment">//判断锁持有的线程是否为当前线程</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">           <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">           <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">           setState(nextc);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="公平锁加锁"><a href="#公平锁加锁" class="headerlink" title="公平锁加锁"></a>公平锁加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractQueueSynchronizer类中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">               acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// ReentrantLock.FairSync中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       acquire(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// ReentrantLock.FairSync中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">       <span class="keyword">int</span> c = getState();</span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">               setExclusiveOwnerThread(current);</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">           <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">           <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">           setState(nextc);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>比非公平锁多出<code>hasQueuedPredecessors()</code>方法，用来判断当前节点前置节点是否为head节点；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Node t = tail;  <span class="comment">//尾节点</span></span><br><span class="line">       Node h = head;  <span class="comment">//头节点</span></span><br><span class="line">       Node s;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//头节点 != 尾节点</span></span><br><span class="line">       <span class="comment">//同步队列第一个节点(头结点的下一个节点)不为null</span></span><br><span class="line">       <span class="comment">//当前线程是同步队列第一个节点</span></span><br><span class="line">       <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">               ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.release(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractQueuedSynchronized.release </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync.tryRelease</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//减掉releases</span></span><br><span class="line">       <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">       <span class="comment">//如果释放的不是持有锁的线程，抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//state == 0 表示已经释放完全了，其他线程可以获取同步状态了</span></span><br><span class="line">       <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">           free = <span class="keyword">true</span>;</span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       setState(c);</span><br><span class="line">       <span class="keyword">return</span> free;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="12）AQS对应JVM底层逻辑，依赖什么技术？其有什么缺点？怎么解决？"><a href="#12）AQS对应JVM底层逻辑，依赖什么技术？其有什么缺点？怎么解决？" class="headerlink" title="12）AQS对应JVM底层逻辑，依赖什么技术？其有什么缺点？怎么解决？"></a>12）AQS对应JVM底层逻辑，依赖什么技术？其有什么缺点？怎么解决？</h4><p>AQS源码获取锁依赖<code>Unsafe</code>，而<code>Unsafe</code>内部方法依赖<code>CAS</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AbstractQueuedSynchronizer</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets synchronization state to the given updated</span></span><br><span class="line"><span class="comment">     * value if the current state value equals the expected value.</span></span><br><span class="line"><span class="comment">     * This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment">     * and write.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that the actual</span></span><br><span class="line"><span class="comment">     *         value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200720023019239.png" alt="image-20200720023019239"></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200720023036720.png" alt="image-20200720023036720"></p>
<p><strong><code>os::is_MP</code></strong>判断当前系统是否为多核系统，如果是就给总线加锁，所以同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。</p>
<h5 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h5><ul>
<li><h6 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a><strong>ABA问题</strong></h6><p>解决方式：</p>
<p><strong>AtomicStampedReference</strong><br>这个类的<code>compareAndSet</code>方法作用是<strong>首先检查当前引用是否等于预期引用</strong>，并且<strong>当前标志是否等于预期标志</strong>，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> T reference;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.reference = reference;</span><br><span class="line">          <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new &#123;<span class="doctag">@code</span> AtomicStampedReference&#125; with the given</span></span><br><span class="line"><span class="comment">   * initial values.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> initialRef the initial reference</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> initialStamp the initial stamp</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AtomicStampedReference</span><span class="params">(V initialRef, <span class="keyword">int</span> initialStamp)</span> </span>&#123;</span><br><span class="line">      pair = Pair.of(initialRef, initialStamp);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Atomically sets the value of both the reference and stamp</span></span><br><span class="line"><span class="comment">   * to the given update values if the</span></span><br><span class="line"><span class="comment">   * current reference is &#123;<span class="doctag">@code</span> ==&#125; to the expected reference</span></span><br><span class="line"><span class="comment">   * and the current stamp is equal to the expected stamp.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newReference the new value for the reference</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> expectedStamp the expected value of the stamp</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> newStamp the new value for the stamp</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                               V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">      Pair&lt;V&gt; current = pair;</span><br><span class="line">    	<span class="comment">// 期望引用 = 当前引用</span></span><br><span class="line">    	<span class="comment">// 期望stamp == 当前stamp</span></span><br><span class="line">    	<span class="comment">// 同时，新的引用 == 当前引用，或者新stamp == 当前值stamp</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">          expectedReference == current.reference &amp;&amp;</span><br><span class="line">          expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">          ((newReference == current.reference &amp;&amp;</span><br><span class="line">            newStamp == current.stamp) ||</span><br><span class="line">           casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><h6 id="循环CAS时间长CPU开销大"><a href="#循环CAS时间长CPU开销大" class="headerlink" title="循环CAS时间长CPU开销大"></a><strong>循环CAS时间长CPU开销大</strong></h6></li>
<li><h6 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a><strong>只能保证一个共享变量的原子操作</strong></h6><p>解决方式：</p>
<p><code>AtomicReference</code>，来保证引用对象之间的原子性，可以把多个变量放到一个对象进行CAS；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> V value;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new AtomicReference with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicReference</span><span class="params">(V initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="1）某个线程获取锁失败的后续流程是什么呢？"><a href="#1）某个线程获取锁失败的后续流程是什么呢？" class="headerlink" title="1）某个线程获取锁失败的后续流程是什么呢？"></a>1）某个线程获取锁失败的后续流程是什么呢？</h4><h4 id="2）既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"><a href="#2）既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？" class="headerlink" title="2）既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"></a>2）既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</h4><h4 id="3）处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"><a href="#3）处于排队等候机制中的线程，什么时候可以有机会获取锁呢？" class="headerlink" title="3）处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"></a>3）处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</h4><h4 id="4）如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？"><a href="#4）如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？" class="headerlink" title="4）如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？"></a>4）如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</h4><h4 id="5）Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？"><a href="#5）Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？" class="headerlink" title="5）Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？"></a>5）Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</h4><h4 id="6）独占锁、共享锁区别？"><a href="#6）独占锁、共享锁区别？" class="headerlink" title="6）独占锁、共享锁区别？"></a>6）独占锁、共享锁区别？</h4><h4 id="7）为什么会有公平锁-非公平锁的设计？"><a href="#7）为什么会有公平锁-非公平锁的设计？" class="headerlink" title="7）为什么会有公平锁/非公平锁的设计？"></a>7）为什么会有公平锁/非公平锁的设计？</h4><ul>
<li><strong>原因一</strong>：<br>恢复挂起的线程到真正锁的获取还是有时间差的，从人类的角度来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以<strong>非公平锁</strong>能更<code>充分的利用 CPU 的时间</code>片，尽量<code>减少 CPU 空闲状态</code>时间。</li>
<li><strong>原因二</strong>：<br>使用多线程很重要的考量点是线程切换的开销，想象一下，如果采用非公平锁，当一个线程请求锁获取同步状态，然后释放同步状态，因为不需要考虑是否还有前驱节点，所以刚释放锁的线程在此刻再次获取同步状态的几率就变得非常大，所以就减少了线程的开销。</li>
</ul>
<h4 id="8）使用公平锁会有什么问题？"><a href="#8）使用公平锁会有什么问题？" class="headerlink" title="8）使用公平锁会有什么问题？"></a>8）使用公平锁会有什么问题？</h4><p>有可能导致排队的长时间在排队，也没有机会获取到锁，这就是传说中的 “饥饿”。</p>
<h4 id="9）如何选择公平锁-非公平锁？"><a href="#9）如何选择公平锁-非公平锁？" class="headerlink" title="9）如何选择公平锁/非公平锁？"></a>9）如何选择公平锁/非公平锁？</h4><p>较高吞吐量，很显然非公平锁是比较合适的，因为节省很多线程切换时间，吞吐量自然就上去了。</p>
<h4 id="10）Synchronized和ReentrantLock区别？"><a href="#10）Synchronized和ReentrantLock区别？" class="headerlink" title="10）Synchronized和ReentrantLock区别？"></a>10）<code>Synchronized</code>和<code>ReentrantLock</code>区别？</h4><ol>
<li><p>与<code>synchronized</code>相比，<code>ReentrantLock</code>提供了更多，更加全面的功能，具备更强的扩展性。</p>
<p>例如：时间锁等候，可中断锁等候，锁投票。</p>
</li>
<li><p><code>ReentrantLock</code>还提供了<code>条件Condition</code>，对线程的等待、唤醒操作更加详细和灵活，所以在多个条件变量和高度竞争锁的地方，<code>ReentrantLock</code>更加适合。</p>
</li>
<li><p><code>ReentrantLock</code>提供了可轮询的锁请求。它会尝试着去获取锁，如果成功则继续，否则可以等到下次运行时处理，而<code>synchronized</code>则一旦进入锁请求要么成功要么阻塞，所以相比<code>synchronized</code>而言，<code>ReentrantLock</code>会不容易产生死锁些。</p>
</li>
<li><p><code>ReentrantLock</code>支持更加灵活的同步代码块，但是使用<code>synchronized</code>时，只能在同一个<code>synchronized</code>块结构中获取和释放。</p>
<p><strong>注：<code>ReentrantLock</code>的锁释放一定要在finally中处理，否则可能会产生严重的后果。</strong></p>
</li>
<li><p><code>ReentrantLock</code>支持中断处理，且性能较<code>synchronized</code>会好些。</p>
</li>
<li><p><code>synchronized</code>依赖于<code>JVM</code>，<code>ReenTrantLock</code>依赖于<code>API</code>；</p>
</li>
<li><p><code>ReenTrantLock</code>比<code>synchronized</code>增加了一些高级功能：</p>
<ul>
<li>等待可中断：<code>ReentrantLock</code>可以通过<code>lock.lockInterruptibly()</code>将正在等待的线程放弃，转而处理其他事情；</li>
<li>可实现公平锁、非公平锁；（<code>Synchronized</code>只能是非公平锁）</li>
<li>可实现选择性通知（绑定多个条件<code>Condition</code>）；</li>
</ul>
</li>
<li><p>资源消耗<code>ReentrantLock</code>大于<code>Synchronized</code>；</p>
</li>
</ol>
<h4 id="11）AQS的设计基于哪种设计模式？"><a href="#11）AQS的设计基于哪种设计模式？" class="headerlink" title="11）AQS的设计基于哪种设计模式？"></a>11）AQS的设计基于哪种设计模式？</h4><p>模版设计模式。</p>
<p>定义：定义一个操作中的算法骨架，而将一些步骤的实现延迟到子类中。</p>
<p>模版方法可以使得子类可以不改变一个算法的结构既可重定义该算法的某些步骤。</p>
<p>其中的模版方法：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727015613400.png" alt="image-20200727015613400"></p>
<blockquote>
<p>参考：</p>
<p><a href="https://mp.weixin.qq.com/s/wIeRxal0gBE4uYY7Nk817g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wIeRxal0gBE4uYY7Nk817g</a></p>
<p><a href="https://mp.weixin.qq.com/s/wIeRxal0gBE4uYY7Nk817g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wIeRxal0gBE4uYY7Nk817g</a></p>
<p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></p>
</blockquote>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2020/07/21/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E8%AE%B2HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8AJDK1-7%E5%92%8C1-8%E5%8C%BA%E5%88%AB%EF%BC%9F/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>PREV</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">2020-07-22</span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签 | tags"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/%E9%9D%A2%E8%AF%95/" title="查看 面试 标签">
                        <b>#</b> 面试
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/java/" title="查看 java 标签">
                        <b>#</b> java
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%B9%B6%E5%8F%91/" title="查看 并发 标签">
                        <b>#</b> 并发
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2020/07/23/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AE%B2%E8%AE%B2Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%9F%E9%9B%86%E7%BE%A4%EF%BC%9F/" target="_self">
                <span>NEXT</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div class="post-catalog" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#AbstractQueueSynchronizer"><span class="toc-text">AbstractQueueSynchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#核心属性"><span class="toc-text">核心属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Node"><span class="toc-text">Node</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#State"><span class="toc-text">State</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#独占锁"><span class="toc-text">独占锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取"><span class="toc-text">获取</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1、首先执行tryAcquire进行尝试获取锁；"><span class="toc-text">1、首先执行tryAcquire进行尝试获取锁；</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2、第1步失败，addWaiter将当前线程节点（Node-EXCLUSIVE）放入链表尾部，并返回Node；"><span class="toc-text">2、第1步失败，addWaiter将当前线程节点（Node.EXCLUSIVE）放入链表尾部，并返回Node；</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3、调用acquireQueued，传入新增的Node；"><span class="toc-text">3、调用acquireQueued，传入新增的Node；</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#为什么要有哨兵节点？"><span class="toc-text">为什么要有哨兵节点？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4、第二步中acquireQueued返回中断状态为true，则Thread-currentThread-interrupt"><span class="toc-text">4、第二步中acquireQueued返回中断状态为true，则Thread.currentThread().interrupt();</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CANCEL节点如何生成？"><span class="toc-text">CANCEL节点如何生成？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#释放"><span class="toc-text">释放</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#为什么从尾部往前查找？"><span class="toc-text">为什么从尾部往前查找？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#共享锁"><span class="toc-text">共享锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取-1"><span class="toc-text">获取</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#释放-1"><span class="toc-text">释放</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可中断独占锁"><span class="toc-text">可中断独占锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#超时可中断独占锁"><span class="toc-text">超时可中断独占锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition"><span class="toc-text">Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#await-加入条件等待队列"><span class="toc-text">await() 加入条件等待队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signal-加入AQS等待队列"><span class="toc-text">signal() 加入AQS等待队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signal-加入AQS等待队列-1"><span class="toc-text">signal()  加入AQS等待队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非公平锁加锁（默认）"><span class="toc-text">非公平锁加锁（默认）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平锁加锁"><span class="toc-text">公平锁加锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放锁"><span class="toc-text">释放锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS"><span class="toc-text">CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12）AQS对应JVM底层逻辑，依赖什么技术？其有什么缺点？怎么解决？"><span class="toc-text">12）AQS对应JVM底层逻辑，依赖什么技术？其有什么缺点？怎么解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#缺陷"><span class="toc-text">缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ABA问题"><span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#循环CAS时间长CPU开销大"><span class="toc-text">循环CAS时间长CPU开销大</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#只能保证一个共享变量的原子操作"><span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）某个线程获取锁失败的后续流程是什么呢？"><span class="toc-text">1）某个线程获取锁失败的后续流程是什么呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？"><span class="toc-text">2）既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3）处于排队等候机制中的线程，什么时候可以有机会获取锁呢？"><span class="toc-text">3）处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4）如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？"><span class="toc-text">4）如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5）Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？"><span class="toc-text">5）Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6）独占锁、共享锁区别？"><span class="toc-text">6）独占锁、共享锁区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7）为什么会有公平锁-非公平锁的设计？"><span class="toc-text">7）为什么会有公平锁&#x2F;非公平锁的设计？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8）使用公平锁会有什么问题？"><span class="toc-text">8）使用公平锁会有什么问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9）如何选择公平锁-非公平锁？"><span class="toc-text">9）如何选择公平锁&#x2F;非公平锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10）Synchronized和ReentrantLock区别？"><span class="toc-text">10）Synchronized和ReentrantLock区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11）AQS的设计基于哪种设计模式？"><span class="toc-text">11）AQS的设计基于哪种设计模式？</span></a></li></ol></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        


  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <div id="vcomments"></div>

  <script>
    new Valine({
      el: '#vcomments',
      appId: 'bSYdbCIyQHwCwv9NC9Fes7mU-gzGzoHsz',
      appKey: 'zuj9HNh3w0O1O5t1nR1yeNHD',
      placeholder: '说出你的想法...',
      avatar: 'retro'
    })
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>

  
        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="https://github.com/YYZ-coder" target="_blank" rel="noopener">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      <a href="">Copyright © YYZ-coder 2020</a>
    </div>
  
    <div class="footer-more">
      <a href="https://github.com/zchengsite/hexo-theme-oranges" target="_blank" rel="noopener">Theme by Oranges | Powered by Hexo</a>
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



    </div>
  </body>
</html>
