<!DOCTYPE html>
<html lang="zh-CN">

  <head>
  <meta charset="utf-8">
  <meta name="author" content="zchengsite, 1451426471@qq.com" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  
  <title>G1垃圾收集器讲解 | coder的特殊身份</title>

  
    <link rel="apple-touch-icon" href="/images/favicon.png">
    <link rel="icon" href="/images/favicon.png">
  

  <!-- Raleway-Font -->
  <link href="https://fonts.googleapis.com/css?family=Raleway&display=swap" rel="stylesheet">

  <!-- hexo site css -->
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  <!-- jquery3.3.1 -->
  <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

  <!-- fancybox -->
  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <script async src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js"></script>
  
<script src="/js/fancybox.js"></script>


  

<meta name="generator" content="Hexo 4.2.1"></head>


  <body>
    <div id="app">
      <div class="header">
  <div class="avatar">
    <a href="/"><img src="/images/avatar.png" alt=""></a>
    <div class="nickname"><a href="/"></a></div>
  </div>
  <div class="navbar">
    <ul>
      
        <li class="nav-item" data-path="/">
          <a href="/">主页</a>
        </li>
      
        <li class="nav-item" data-path="/archives/">
          <a href="/archives/">归档</a>
        </li>
      
        <li class="nav-item" data-path="/categories/">
          <a href="/categories/">分类</a>
        </li>
      
        <li class="nav-item" data-path="/tags/">
          <a href="/tags/">标签</a>
        </li>
      
        <li class="nav-item" data-path="/about/">
          <a href="/about/">关于</a>
        </li>
      
    </ul>
  </div>
</div>


<script src="/js/activeNav.js"></script>



      <div class="flex-container">
        <!-- 文章详情页，展示文章具体内容，url形式：https://yoursite/文章标题/ -->
<!-- 同时为「标签tag」，「朋友friend」，「分类categories」，「关于about」页面的承载页面，具体展示取决于page.type -->


  
  
  
  
  
  
  
  
  <!-- 文章内容页 url形式：https://yoursite/文章标题/ -->
  <div class="container post-details" id="post-details">
    <div class="post-content">
      <div class="post-title">G1垃圾收集器讲解</div>
      <div class="post-attach">
        <span class="post-pubtime">2020-07-26</span>
        
              <span class="post-tags">
                <i class="iconfont icon-tags" title="标签 | tags"></i>
                
                <span class="span--tag">
                  <a href="/tags/JVM/" title="查看 JVM 标签">
                    <b>#</b> JVM
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="查看 垃圾收集器 标签">
                    <b>#</b> 垃圾收集器
                  </a>
                </span>
                
                <span class="span--tag">
                  <a href="/tags/G1/" title="查看 G1 标签">
                    <b>#</b> G1
                  </a>
                </span>
                
              </span>
          
      </div>
      <div class="markdown-body">
        <p>G1垃圾收集器（<code>Garbage First</code>），从JDK7 开始提供，是一种响应时间优先的GC算法。</p>
<p>G1致力于在多CPU和大内存服务器上对垃圾回收提供<strong>软实时目标</strong>和<strong>高吞吐量</strong>。</p>
<ul>
<li>使用“<code>复制+标记整理算法</code>”，跨新生代和老年代；</li>
<li>标记整理 + 化整为零；</li>
</ul>
<p>不同于之前的<code>CMS</code>、<code>PS</code>、<code>SericalOld</code>、<code>ParallelNew</code>…等收集器。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h2><ul>
<li><p><strong>G1会根据预测时间动态改变新生代大小；</strong></p>
<p>其他垃圾回收新生代的大小也可以动态变化，但这个变化主要是根据内存的使用情况进行的。</p>
<p>G1中则是以预测时间为导向，根据内存的使用情况调整新生代分区的数目。</p>
</li>
<li><p><strong>G1老年代的垃圾回收方式与其他JVM垃圾回收器对老年代的处理不同：</strong></p>
<p>G1老生代的收集不会为了释放老生代的空间对整个老生代做回收。相反，在任意时刻只有一部分老生代分区会被回收，并且，这部分老生代分区将在下一次<strong>增量回收</strong>时与所有的新生代分区一起被收集。<br>这就是我们所说的混合回收（<code>Mixed GC</code>）。</p>
</li>
<li><p><code>G1</code>取消了传统的固定分代区域，取而代之的是<strong>将内存区域分为多个<code>Reigon</code></strong>，每个区域都可以根据需要扮演新生代的<code>Eden</code>或者<code>Survivor</code>，又或者<code>PermGen</code>。</p>
</li>
<li><p><code>G1</code>采用<strong>增量回收</strong>的方式，每次回收一些区块，而不是整堆回收，提高了清理的效率。</p>
</li>
<li><p><strong>吸收了以下算法的优势：</strong></p>
<ul>
<li><strong>列车算法（对内存进行分区）</strong></li>
<li><strong>CMS（对分区进行并发标记）</strong></li>
<li><strong>最老优先（最老垃圾数据优先收集）</strong></li>
</ul>
</li>
<li><p><strong>并发标记阶段出现漏标的处理方式SATB的处理速度比起CMS的方法更快。</strong></p>
</li>
<li><p><strong>与CMS回收过程相比</strong>：</p>
<p>初始标记，并发标记，重新标记，清理垃圾四个阶段很像，但是<code>G1</code>中有很多标记<code>region</code>的操作，并借助<code>Rset</code>进行了范围的缩小，提高了并发标记的速度。初始标记和<code>YGC</code>的<code>STW</code>一起了，提高了效率；</p>
<p>并发标记因为<code>RSet</code>的设计，扫描范围缩小了，提高了效率；</p>
<p>重新标记因为使用了<code>SATB</code>提高了效率；清理虽然造成了<code>STW</code>，但是复制使内存紧凑，避免了内存碎片。</p>
<p>同时只清理垃圾较多的<code>region</code>，最大限度的降低了<code>STW</code>时间。</p>
</li>
</ul>
<blockquote>
<p>参考：《JVM G1 源码分析与调优》</p>
</blockquote>
<h2 id="内存划分"><a href="#内存划分" class="headerlink" title="内存划分"></a>内存划分</h2><p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727144749035.png" alt="image-20200727144749035"></p>
<h3 id="分区类型分为？"><a href="#分区类型分为？" class="headerlink" title="分区类型分为？"></a>分区类型分为？</h3><ul>
<li><p><strong>自由分区（Free Heap Region，FHR）</strong></p>
</li>
<li><p><strong>新生代分区（Young Heap Region，YHR）</strong></p>
<p><code>-XX:G1MaxNewSizePercent</code>（默认60）和<code>-XX:G1NewSizePercent</code>（默认5）控制<strong>新生代</strong>大小。</p>
</li>
<li><p><strong>大对象分区（Humongous Heap Region，HHR，本质还是O区的）</strong></p>
<ul>
<li><strong>大对象头分区</strong></li>
<li><strong>大对象连续分区</strong></li>
</ul>
</li>
<li><p><strong>老生代分区（Old Heap Region，OHR）</strong></p>
</li>
</ul>
<p>图中，<code>Humongous</code>区域（短期存在）：</p>
<p>大对象（当新建对象大小超过Region区域的一半）放到<code>Humongous</code>区域（新的一个区域），若对象大小超过一个<code>Humongous</code>区域，则多个连续<code>Humongous</code>存储。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 大小默认为0，指定分区大小（1MB ～ 32MB，且必须是2的幂），默认将整堆划分为`2048`个分区。</span></span><br><span class="line">-XX:G1HeapRegionSize=0</span><br></pre></td></tr></table></figure>

<p>最大能够支持的内存大小为：<code>32MB * 2048 = 65536 = 64G</code>内存；</p>
<h3 id="Heap-Region大小确定方式？"><a href="#Heap-Region大小确定方式？" class="headerlink" title="Heap Region大小确定方式？"></a><strong>Heap Region大小确定方式？</strong></h3><ul>
<li><p>指定大小（<code>-XX:G1HeapRegionSize</code>）；</p>
</li>
<li><p><strong>启发式推断</strong>：即在不指定<code>Heap Region</code>大小的时候，由<code>G1</code>启发式推断<code>Heap Region</code>大小。</p>
<p>HR启发式推断根据堆空间的最大值和最小值以及HR个数进行推断。</p>
</li>
</ul>
<h3 id="如果G1是启发式推断新生代的大小，那么当新生代变化时该如何实现？"><a href="#如果G1是启发式推断新生代的大小，那么当新生代变化时该如何实现？" class="headerlink" title="如果G1是启发式推断新生代的大小，那么当新生代变化时该如何实现？"></a>如果G1是启发式推断新生代的大小，那么当新生代变化时该如何实现？</h3><p>使用一个<strong>分区列表</strong>，扩张时如果有空闲的分区列表则可以直接把空闲分区加入到新生代分区列表中，如果没有的话则分配新的分区然后把它加入到新生代分区列表中。</p>
<p><code>G1</code>有一个线程专门抽样处理预测新生代列表的长度应该多大，并动态调整。</p>
<h3 id="分配新的分区时，何时扩展？一次扩展多少内存？"><a href="#分配新的分区时，何时扩展？一次扩展多少内存？" class="headerlink" title="分配新的分区时，何时扩展？一次扩展多少内存？"></a>分配新的分区时，何时扩展？一次扩展多少内存？</h3><p>G1是自适应扩展内存空间的。</p>
<ul>
<li>先根据历史信息获取平均GC时间；</li>
<li>G1 <strong>GC时间与应用时间</strong>占比不超过<code>10%</code>时不需要动态扩展，当GC时间超过这个阈值的10%，可以动态扩展。</li>
</ul>
<p>参数<code>-XX:GCTimeRatio</code>表示<strong>GC与应用的耗费时间比</strong>，G1中默认为9。计算方式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_gc_overhead_perc = <span class="number">100.0</span>×(<span class="number">1.0</span>/(<span class="number">1.0</span>+GCTimeRatio))</span><br></pre></td></tr></table></figure>

<p>扩展时有一个参数<code>G1ExpandByPercentOfAvailable</code>（默认值是20）来控制一次扩展的比例，即每次都至少从未提交的内存中申请20%，有下限要求（一次申请的内存不能少于1M，最多是当前已分配的一倍）。</p>
<h2 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a>GC模式</h2><p><code>G1</code>提供了两种<strong>GC模式</strong>：</p>
<ul>
<li><p><code>Young GC</code></p>
<p>选定所有年轻代里的<code>Region</code>。通过控制年轻代的<code>region</code>个数，即年轻代内存大小，来控制<code>young GC</code>的时间开销。</p>
</li>
<li><p><code>Mixed GC</code>（非<code>Full GC</code>）</p>
<p>选定所有年轻代里的<code>Region</code>，外加根据<code>global concurrent marking</code>统计得出收集收益高的若干<code>老年代Region</code>。</p>
<p>在用户指定的开销目标范围内尽可能选择收益高的<code>老年代Region</code>。（只能回收老年代部分region）</p>
</li>
</ul>
<p><strong>注：如果<code>mixed GC</code>实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行<code>Mixed GC</code>，就会使用<code>serial old GC</code>（f<code>ull GC</code>）来收集整个<code>GC heap</code>。</strong></p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+UseG1GC</td>
<td align="left">使用G1垃圾收集器</td>
</tr>
<tr>
<td align="left">-XX:G1OldCSetRegionThresholdPercent</td>
<td align="left">一次<code>Mixed GC</code>中能被选入CSet的最多<code>old generation region</code>数量。</td>
</tr>
<tr>
<td align="left">-XX:G1MixedGCCountTarget</td>
<td align="left">一次<code>global concurrent marking</code>（指的是Mixed GC过程）之后，最多执行<code>Mixed GC</code>的次数。</td>
</tr>
<tr>
<td align="left">-XX:G1MixedGCLiveThresholdPercent</td>
<td align="left"><code>old generation region</code>中的存活对象的占比，只有在此参数之下，才会被选入<code>CSet</code>。</td>
</tr>
<tr>
<td align="left">-XX:G1HeapWastePercent</td>
<td align="left">在<code>global concurrent marking</code>（指的是Mixed GC过程）结束之后，我们可以知道<code>old gen regions</code>中有多少空间要被回收，在每次<code>YGC</code>之后和再次发生<code>Mixed GC</code>之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生<code>Mixed GC</code>。</td>
</tr>
<tr>
<td align="left">-XX:G1HeapRegionSize=n</td>
<td align="left">设置Region大小，并非最终值</td>
</tr>
<tr>
<td align="left">-XX:MaxGCPauseMillis</td>
<td align="left">设置G1收集过程目标时间，默认值200ms，不是硬性条件（期望值）</td>
</tr>
<tr>
<td align="left">-XX:G1NewSizePercent</td>
<td align="left">新生代最小值，默认值5%</td>
</tr>
<tr>
<td align="left">-XX:G1MaxNewSizePercent</td>
<td align="left">新生代最大值，默认值60%</td>
</tr>
<tr>
<td align="left">-XX:ParallelGCThreads</td>
<td align="left">STW期间，并行GC线程数</td>
</tr>
<tr>
<td align="left">-XX:ConcGCThreads=n</td>
<td align="left">并发标记阶段，并行执行的线程数</td>
</tr>
<tr>
<td align="left">-XX:InitiatingHeapOccupancyPercent</td>
<td align="left">设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是<code>non_young_capacity_bytes</code>，包括<code>old+humongous</code></td>
</tr>
</tbody></table>
<h2 id="收集过程"><a href="#收集过程" class="headerlink" title="收集过程"></a>收集过程</h2><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><code>STW</code></p>
<p>主要是对<code>Eden</code>区进行<code>GC</code>，它在<code>Eden</code>空间耗尽时会被触发。</p>
<p>在这种情况下，<code>Eden</code>空间的数据移动到<code>Survivor</code>空间中，如果<code>Survivor</code>空间不够，<code>Eden</code>空间的部分数据会直接晋升到年老代空间。<code>Survivor</code>区的数据移动到新的<code>Survivor</code>区中，也有部分数据晋升到老年代空间中。</p>
<p>最终<code>Eden</code>空间的数据为空，<code>GC</code>停止工作，应用线程继续执行。</p>
<blockquote>
<p>在G1中，并没有使用<code>point-out</code>，这是由于一个分区太小，<strong>分区数量太多</strong>，如果是用<code>point-out</code>的话，<strong>会造成大量的扫描浪费</strong>，有些根本不需要GC的分区引用也扫描了。</p>
<p>于是G1中使用<code>point-in</code>来解决。（<code>point-in</code>的意思是<strong>哪些分区引用了当前分区中的对象</strong>）</p>
<p>这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。</p>
<p>由于新生代有多个，那么我们<strong>需要在新生代之间记录引用吗？</strong></p>
<p>这是不必要的，原因在于每次GC时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p>
<p>参考：<a href="https://www.cnblogs.com/ASPNET2008/p/6496481.html" target="_blank" rel="noopener">https://www.cnblogs.com/ASPNET2008/p/6496481.html</a></p>
</blockquote>
<ul>
<li><p>根（Root Scan）扫描：</p>
<p>静态和本地对象被扫描；</p>
</li>
<li><p>更新RSet：</p>
<p>处理<code>dirty card队列</code>更新<code>RS</code>；</p>
</li>
<li><p>处理RSet：</p>
<p>检测从年轻代指向年老代的对象；</p>
</li>
<li><p>对象拷贝：</p>
<p>拷贝存活的对象到<code>survivor/old</code>区域；</p>
</li>
<li><p>处理引用队列：</p>
<p>软引用，弱引用，虚引用处理；</p>
</li>
</ul>
<h3 id="Mixed-GC（Concurrent-marking）"><a href="#Mixed-GC（Concurrent-marking）" class="headerlink" title="Mixed GC（Concurrent marking）"></a>Mixed GC（Concurrent marking）</h3><h4 id="那么什么时候会启动并发标记周期呢（Mixed-GC）？"><a href="#那么什么时候会启动并发标记周期呢（Mixed-GC）？" class="headerlink" title="那么什么时候会启动并发标记周期呢（Mixed GC）？"></a><strong>那么什么时候会启动并发标记周期呢（Mixed GC）？</strong></h4><p>这个是通过参数控制的，下面马上要介绍这个参数了，此参数默认值是 45，也就是说当堆空间使用了 <code>45%</code> 后，G1 就会进入并发标记周期。（<code>-XX:InitiatingHeapOccupancyPercent = 45</code>）</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727144936253.png" alt="image-20200727144936253"></p>
<h4 id="初始标记（Initial-Marking）"><a href="#初始标记（Initial-Marking）" class="headerlink" title="初始标记（Initial Marking）"></a>初始标记（Initial Marking）</h4><p><strong>需要<code>STW</code>。</strong></p>
<p>仅仅是为了<strong>标记<code>GC roots</code>能关联到的对象</strong>，并且<strong>修改<code>TAMS（Top At Mark Start）</code>的值，让下一阶段用户程序并发执行时，能在正确可用的<code>Region</code>中创建新对象</strong>。</p>
<p>此处共用了YoungGC的暂停，可以复用root scan操作。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC pause (G1 Evacuation Pause) (young) (initial-mark), 0.0062656 secs]</span><br></pre></td></tr></table></figure>



<h5 id="TAMS是什么？"><a href="#TAMS是什么？" class="headerlink" title="TAMS是什么？"></a>TAMS是什么？</h5><p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200728122703893.png" alt="image-20200728122703893"></p>
<p>要达到<code>GC</code>与用户线程并发执行，必须要解决回收过程中新对象的分配，所以<code>G1</code>为每个<code>Region区域</code>设计了两个名为<code>TAMS</code>的指针，从<code>Region区域</code>划分出一部分空间用于记录并发并发回收过程的新对象（存活，不纳入gc），位于 TAMS 之后分配的对象都视为活跃，这也叫做隐式标记。。</p>
<blockquote>
<p>两个 TAMS 指针，表示当前的 nextTAMS 和上一轮标记的 prevTAMS，也有两个记录对象标记的 nextBitmap 和 prevBitmap。</p>
<p><strong>为什么要放两个 TAMS 指针和 bitmap 呢？</strong></p>
<p>猜测可能是因为 G1GC 的 Evacuation 并不一定等待 Mark 阶段结束才开始，在 Concurrent Mark 期间也可能进入 Evacuation 阶段，这时会选用 prevTAMS 和 prevBitmap 做为标记信息，它们扮演了一个快照，能回收掉上一轮标记时发现的垃圾对象，在 Concurrent Mark 完成之后再进入 Evacuation 阶段的话，再取当前的 nextTAMS 和 nextBitmap。</p>
</blockquote>
<h4 id="RootRegion扫描（Root-Region-Scan）"><a href="#RootRegion扫描（Root-Region-Scan）" class="headerlink" title="RootRegion扫描（Root Region Scan）"></a><strong>RootRegion扫描</strong>（Root Region Scan）</h4><p>扫描整个<code>old区</code>所有<code>region</code>，看看<code>region</code>的<code>RSet</code>中是否含有其他地方的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.362: [GC concurrent-root-region-scan-start]</span><br><span class="line">1.364: [GC concurrent-root-region-scan-end, 0.0028513 secs]</span><br></pre></td></tr></table></figure>

<h5 id="作用？"><a href="#作用？" class="headerlink" title="作用？"></a>作用？</h5><p>标记出<code>RootRegion</code>指向<code>Old Region</code>的<code>region</code>，标记这些<code>region</code>是<strong>为了降低并发标记的扫描范围</strong>，因为并发标记需要扫描<code>GCROOT</code>引用或间接的所有对象，而这些对象一定是在<code>RootRegion</code>出发指向的<code>Region</code>中的。</p>
<p><code>MixGC</code>中<code>Young Region</code>本来就要全扫，所以这里再按照<code>Old Region</code>过滤下，这样就缩小了扫描范围。</p>
<p>该阶段的操作为遍历<code>Old Region</code>查询<code>Rset</code>是否有来自<code>RootRegion</code>的（<code>RootRegion</code>是初始标记得到的）。</p>
<h4 id="并发标记（Concurrent-Marking）"><a href="#并发标记（Concurrent-Marking）" class="headerlink" title="并发标记（Concurrent Marking）"></a>并发标记（Concurrent Marking）</h4><p><strong>缩小遍历范围。</strong></p>
<p>从<code>GC roots</code>开始对堆中的对象进行可达性分析，找出存活对象，可以和用户线程并发执行。</p>
<p>当对象扫描完成后，并发时用户线程可能会有引用变动的对象，这些对象有可能会<strong>漏标（G1中使用SATB解决）</strong></p>
<p>（<strong>漏标</strong>解决方式：<code>三色标记</code>，后面会抽出一篇文章论述）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.364: [GC concurrent-mark-start]</span><br><span class="line">1.645: [GC concurrent-mark-end, 0.2803470 secs]</span><br></pre></td></tr></table></figure>



<h4 id="最终-重新标记（Final-Marking）"><a href="#最终-重新标记（Final-Marking）" class="headerlink" title="最终/重新标记（Final Marking）"></a>最终/重新标记（Final Marking）</h4><p><strong>使用<code>SATB</code>记录标记。会发生STW</strong></p>
<p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，<br>虚拟机将这部分变化记录到线程<code>Remember Set Logs</code>中。<br>这个阶段需要把<code>Remember Set Logs</code>合并到<code>Remember Set</code>中，需要停顿线程，但是可以并行执行。</p>
<p>用来处理并发阶段后遗留下少量的<code>SATB记录</code>（<strong>漏标</strong>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.645: [GC remark 1.645: [Finalize Marking, 0.0009461 secs] </span><br><span class="line">1.646: [GC ref-proc, 0.0000417 secs] 1.646: [Unloading, 0.0011301 secs], 0.0074056 secs]</span><br><span class="line">[Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure>



<h4 id="筛选回收-清除垃圾（Live-Data-Counting-and-Evacuation）-（CleanUp）"><a href="#筛选回收-清除垃圾（Live-Data-Counting-and-Evacuation）-（CleanUp）" class="headerlink" title="筛选回收/清除垃圾（Live Data Counting and Evacuation）/（CleanUp）"></a>筛选回收/清除垃圾（Live Data Counting and Evacuation）/（CleanUp）</h4><p>首先对各个<code>Regin</code>的回收价值和成本进行<code>排序</code>，根据用户的期望GC停顿时间来<code>制定回收计划</code>。<br>这个阶段也可以与用户线程并发执行，因为只回收一部分<code>Regin</code>，时间是可控的。</p>
<p><strong>清除空Region（没有存活对象的），加入到<code>free list</code>。</strong></p>
<p><strong>选择所有Young区reigons和’对象存活率较低’的Old区regions组成Csets，进行复制清理；</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.652: [GC cleanup 1213M-&gt;1213M(1885M), 0.0030492 secs]</span><br><span class="line">[Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.00 secs]</span><br></pre></td></tr></table></figure>



<h3 id="混合式垃圾收集"><a href="#混合式垃圾收集" class="headerlink" title="混合式垃圾收集"></a>混合式垃圾收集</h3><p><strong>并发垃圾回收</strong>周期结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发周期。</p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p>导致Full GC的情况：</p>
<ul>
<li><p><strong>concurrent mode failure（并发模式收集失败）；</strong></p>
<p>并发模式失败，CMS 收集器也有同样的概念。</p>
<p>G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记。</p>
<p>这个时候说明：</p>
<p>1、堆需要增加了；</p>
<p>2、或者需要调整并发周期，如增加并发标记的线程数量，让并发标记尽快结束；</p>
<p>3、或者就是更早地进行并发周期，默认是整堆内存的 45% 被占用就开始进行并发周期。</p>
<p><strong>解决方式：</strong></p>
<p>G1启动标记周期，但在<code>Mix GC</code>之前，老年代就被填满，这时候<code>G1</code>会放弃标记周期。</p>
<p>这种情形下，需要<strong>增加堆大小</strong>，或者<strong>调整周期</strong>（例如：增加线程数<code>-XX:ConcGCThreads</code>等）。</p>
</li>
<li><p><strong>晋升失败</strong></p>
<p>并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致<strong>老年代不够用</strong>，那么会发生晋升失败。</p>
<p><strong>解决方式：</strong></p>
<p>G1在进行GC的时候没有足够的内存供存活对象或晋升对象使用，由此触发了<code>Full GC</code>。可以在日志中看到（<code>to-space exhausted</code>）或者（<code>to-space overflow</code>）。解决这种问题的方式是：</p>
<ul>
<li>增加 <code>-XX:G1ReservePercent</code> 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量；</li>
<li>通过减少<code>-XX:InitiatingHeapOccupancyPercent</code>提前启动标记周期；</li>
<li>也可以通过增加 <code>-XX:ConcGCThreads</code> 选项的值来增加并行标记线程的数目；</li>
</ul>
</li>
<li><p><strong>疏散失败</strong></p>
<p>年轻代垃圾收集的时候，如果 <code>Survivor</code>和 <code>Old 区</code>没有足够的空间容纳所有的存活对象。</p>
<p>这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</p>
<p><strong>解决方式：</strong></p>
<p>如上</p>
</li>
<li><p><strong>大对象分配失败</strong></p>
<p>应该尽可能地不创建大对象，尤其是大于一个区块大小的那种对象。</p>
<p><strong>解决方式：</strong></p>
<p>当巨型对象找不到合适的空间进行分配时，就会启动<code>Full GC</code>，来释放空间。</p>
<p>这种情况下，应该避免分配大量的巨型对象，增加内存或者增大<code>-XX:G1HeapRegionSize</code>，使巨型对象不再是巨型对象。</p>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>G1跟踪各个<code>Region</code>里面的垃圾堆积的<strong>价值大小</strong>（回收所获得的空间大小以及回收所需时间经验值），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的<code>Regin</code>。</p>
<p>这种方式保证来G1收集器在有限时间内可以获取尽可能高的收集效率。</p>
<h3 id="可预测停顿-amp-追求停顿时间"><a href="#可预测停顿-amp-追求停顿时间" class="headerlink" title="可预测停顿 &amp; 追求停顿时间"></a><strong>可预测停顿</strong> &amp; 追求停顿时间</h3><p>能够建立可以预测的停顿时间模型，预测停顿时间。</p>
<p><code>-XX:MaxGCPauseMillis</code>指定目标期望的最大停顿时间。</p>
<p>G1会尝试调整新生代和老年代的比例，堆大小，晋升年龄等来达到这个目标时间。</p>
<h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a><strong>并行与并发</strong></h3><p>G1能充分利用多CPU，多核环境下的硬件优势，来缩短<code>Stop the World</code>，是并发的收集器。</p>
<h3 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a><strong>空间整合</strong></h3><p><code>G1</code>从整体来看是基于标记-整理算法，从局部（两个<code>Region</code>）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。</p>
<p>不会提前触发一次<code>Full GC</code>，有利于程序长时间运行。</p>
<h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a><strong>分代收集</strong></h3><p>G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。</p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="内存区域不固定"><a href="#内存区域不固定" class="headerlink" title="内存区域不固定"></a>内存区域不固定</h3><p><code>Region</code>这一时间段为<code>Young Region</code>，下一次<code>GC</code>后可能变为<code>Old Region</code>，或者其他类型<code>Region</code>。</p>
<h3 id="G1停顿预测模型（Pause-Prediction-Model）"><a href="#G1停顿预测模型（Pause-Prediction-Model）" class="headerlink" title="G1停顿预测模型（Pause Prediction Model）"></a>G1停顿预测模型（Pause Prediction Model）</h3><p>用户可以设定整个GC过程的期望停顿时间，由参数<code>-XX:MaxGCPauseMillis</code>控制，默认值<code>200ms</code>。</p>
<p>不过它不是硬性条件，只是期望值，G1会努力在这个目标停顿时间内完成垃圾回收的工作，但是它不能保证，即也可能完不成（比如我们设置了太小的停顿时间，新生代太大等）。</p>
<blockquote>
<p>它在G1中的作用是：</p>
<p>G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target.</p>
<p>G1使用一个暂停预测模型来满足用户定义的暂停时间目标，并根据指定的暂停时间目标选择要收集的区域数。</p>
</blockquote>
<p>G1的预测逻辑是基于<strong>衰减平均值</strong>和<strong>衰减标准偏差</strong>，且以衰减标准偏差为理论基础实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  share/vm/gc_implementation/g1/g1CollectorPolicy.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_new_prediction</span><span class="params">(TruncatedSeq* seq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MAX2(seq-&gt;davg() + sigma() * seq-&gt;dsd(),</span><br><span class="line">                seq-&gt;davg() * confidence_factor(seq-&gt;num()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>衰减平均（Decaying Average）</strong>是一种简单的数学方法，用来计算一个<strong>数列的平均值</strong>，核心是给近期的数据更高的权重，即强调近期数据对结果的影响。（<code>davg()</code>）</p>
<blockquote>
<p>davg表示衰减均值；</p>
<p>sigma()返回一个系数，表示信赖度；</p>
<p>dsd表示衰减标准偏差；</p>
<p>confidence_factor表示可信度相关系数；</p>
<p>方法的参数TruncateSeq，是一个截断的序列，它只跟踪了序列中的最新的n个元素。</p>
</blockquote>
<p>在<code>G1 GC</code>过程中，每个可测量的步骤花费的时间都会记录到<code>TruncateSeq</code>（继承了<code>AbsSeq</code>）中，用来计算衰减均值、衰减变量，衰减标准偏差等。</p>
<h3 id="跨代引用"><a href="#跨代引用" class="headerlink" title="跨代引用"></a>跨代引用</h3><p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727152631049.png" alt="image-20200727152631049"></p>
<h3 id="RSet（记忆集：Remember-Set）"><a href="#RSet（记忆集：Remember-Set）" class="headerlink" title="RSet（记忆集：Remember Set）"></a><strong>RSet（记忆集：Remember Set）</strong></h3><p>在G1中每个<code>Reigon</code>初始化时，会初始化一个<code>RSet</code>；</p>
<p>用于<strong>记录/跟踪</strong>进入该区块的对象引用（如区块 A 中的对象引用了区块 B，区块 B 的 Rset 需要记录这个信息），它用于实现收集过程的并行化以及使得区块能进行独立收集。</p>
<p>总体上 <code>Remembered Sets</code>消耗的内存小于 <code>5%</code>。</p>
<p><strong>注：</strong></p>
<p><strong>每个<code>Region</code>默认按照<code>512Kb</code>划分成多个<code>Card</code>，所以<code>RSet</code>需要记录的东西应该是 <code>xx Region</code>的<code>xx Card</code>。</strong></p>
<p>（如下图：<code>Region1</code>和<code>Region3</code>中有对象引用了<code>Region2</code>的对象，则在<code>Region2</code>的<code>Rset</code>中记录了这些引用）</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727201652054.png" alt="image-20200727201652054"></p>
<h4 id="RSet实现过程"><a href="#RSet实现过程" class="headerlink" title="RSet实现过程"></a>RSet实现过程</h4><p>为了维护这些<code>RSet</code>，如果每次给引用类型的字段赋值都要更新<code>RSet</code>，这带来的额外开销实在太大，<code>G1</code>中采用<code>post-write barrier</code>和<code>concurrent refinement threads</code>实现了<code>RSet</code>的更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设对象young和old分别在不同的Region中</span></span><br><span class="line">Object young = <span class="keyword">new</span> Object();</span><br><span class="line">old.p = young;</span><br></pre></td></tr></table></figure>

<p><code>Java</code>层面给<code>old对象</code>的p字段赋值<code>young对象</code>之后，<code>jvm底层</code>会执行<code>oop_store</code>方法，实现位于<code>oop.inline.hpp</code>类中。</p>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a><strong>赋值</strong></h5><p><a href="https://en.wikipedia.org/wiki/Write_barrier" target="_blank" rel="noopener">Write barrier</a></p>
<p>在<strong>赋值</strong>动作（object.a = xxx）的前后，<code>JVM</code>插入一个<code>pre-write barrier</code>和<code>post-write barrier</code>，其中<code>post-write barrier</code>的最终动作如下：</p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727205016788.png" alt="image-20200727205016788"></p>
<ol>
<li>找到该对象引用所在的位置（<code>Card</code>），并设置为<code>dirty_card</code>；</li>
<li>如果当前是应用线程，每个Java线程有一个<code>dirty card queue</code>，把该<code>card</code>插入队列；</li>
<li>除了每个线程自带的<code>dirty card queue</code>，还有一个全局共享的<code>queue</code>；</li>
</ol>
<h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a><strong>修改</strong></h5><p><code>RSet</code>更新操作交由多个<code>ConcurrentG1RefineThread</code>并发完成，每当全局队列集合超过一定阈后，<code>ConcurrentG1RefineThread</code>会取出若干个队列，遍历每个队列中记录的<code>card</code>，并进行处理，位于<code>G1RemSet::refine_card</code>方法，大概实现逻辑如下：</p>
<ol>
<li>根据<code>card</code>的地址，计算出<code>card</code>所在的<code>Region</code>；</li>
<li>如果<code>Region</code>不存在，或者<code>Region</code>是<code>Young</code>区，或者该<code>Region</code>在回收集合中，则不进行处理；</li>
<li>最终使用闭合函数<code>G1UpdateRSOrPushRefOopClosure::do_oop_nv()</code>的处理该<code>card</code>中的对象；</li>
</ol>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727211125384.png" alt="image-20200727211125384"></p>
<p>其中<code>_from</code>是持有引用的对象所在的<code>Region</code>，<code>to</code>是引用对象所在的<code>Region</code>，通过<code>add_reference</code>方法加入到<code>RSet</code>中，更细节的实现在<code>OtherRegionsTable::add_reference</code>方法中，有兴趣的同学可以继续研究，比如<code>RSet</code>的存储结构。</p>
<h3 id="Collection-Set（CSet）"><a href="#Collection-Set（CSet）" class="headerlink" title="Collection Set（CSet）"></a>Collection Set（CSet）</h3><p>它记录了<code>GC</code>要收集的<code>Region</code>集合，集合里的<code>Region</code>可以是任意年代的。</p>
<p>在<code>GC</code>的时候，对于<code>old-&gt;young</code>和<code>old-&gt;old</code>的跨代对象引用，只要扫描对应的<code>CSet</code>中的<code>RSet</code>即可，同时，在这些区块中的对象会被复制到其他区块中，总体上 <code>Collection Sets</code> 消耗的内存小于 <code>1%</code>。</p>
<h3 id="CardTable（记录扫描跨代引用内存区域）"><a href="#CardTable（记录扫描跨代引用内存区域）" class="headerlink" title="CardTable（记录扫描跨代引用内存区域）"></a><strong>CardTable（记录扫描跨代引用内存区域）</strong></h3><p>由于<code>新生代GC</code>时，需要扫描整个<code>Old区</code>，效率很低。同时，倘若引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在G1 中又引入了另外一个概念，卡表（<code>Card Table</code>）。</p>
<p>一个<code>Card Table</code>将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于<code>128到512字节</code>之间。<code>Card Table</code>通常为<strong>字节数组</strong>，由<code>Card</code>的索引（即数组下标）来标识每个分区的空间地址。</p>
<p>默认情况下，每个卡Card都未被引用。当一个地址空间被引用时，标记为<strong>脏被引用</strong>，此外RSet也将这个数组下标记录下来。</p>
<p><strong>一般情况下，这个RSet其实是一个<code>Hash Table</code>，<code>Key</code>是别的<code>Region</code>的起始地址，<code>Value</code>是一个集合，里面的元素是<code>Card Table</code>的<code>Index</code>。</strong></p>
<p><img src="http://qd2x6jysb.bkt.clouddn.com/image-20200727153252300.png" alt="image-20200727153252300"></p>
<p>下面举个例子：</p>
<blockquote>
<p>有两个分区，假设分区大小都为1MB，分别为A和B。如果A中有一个对象objA，B中有一个对象objB，且objA.field=objB，那么这两个分区就有引用关系了，但是如果我们想找到分区A，要如何引用分区B？</p>
</blockquote>
<p>借助额外的数据结构描述这种引用关系，例如使用类似位图（<code>bitmap</code>）的方法，记录A和B的内存块之间的引用关系，用一个位来描述一个字，假设在32位机器上（一个字为32位），需要<code>32KB</code>（<code>32KB×32=1M</code>）的空间来描述一个分区。</p>
<p>那么我们就可以在这个<code>对象ObjA</code>所在<code>分区A</code>里面添加一个额外的指针，这个指针<strong>指向另外一个<code>分区B</code>的位图</strong>，如果我们可以把<code>对象ObjA</code>和指针关系进行映射，那么当访问<code>ObjA</code>的时候，顺便访问这个额外的指针，从这个指针指向的位图就能找到被<code>ObjA</code>引用的<code>分区B</code>对应的内存块。</p>
<p>通常我们只需要判定位图里面对应的位是否有1，有的话则认为发生了引用。</p>
<p><strong>局限性：</strong></p>
<p><strong>以位为粒度的位图能准确描述每一个字的引用关系，但是一个位通常包含的信息太少，只能描述2个状态：引用还是未引用。</strong></p>
<p><strong><code>RSet</code>和<code>CardTable</code>用来避免<code>YoungGC</code>全部扫描老年代对象。</strong></p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul>
<li><p>G1 需要记忆集RSets （具体来说是卡表）来记录新生代和老年代之间的引用关系，这种数据结构在 G1 中需要占用大量的内存，可能达到整个堆内存容量的 <code>20%</code> 甚至更多。</p>
<p>而且 G1 中维护记忆集的成本较高，带来了更高的执行负载，影响效率。</p>
</li>
<li><p>不适用小内存应用上，大内存使用更有优势（界限：<code>6~8GB</code>）</p>
</li>
</ul>
<h2 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h2><h3 id="XX-MaxGCPauseMillis-200（建立G1停顿预测模型）"><a href="#XX-MaxGCPauseMillis-200（建立G1停顿预测模型）" class="headerlink" title="-XX:MaxGCPauseMillis=200（建立G1停顿预测模型）"></a><code>-XX:MaxGCPauseMillis=200</code>（建立G1停顿预测模型）</h3><p><strong>那<code>G1</code>是如何做到最大暂停时间的呢？</strong></p>
<p>这涉及到另一个概念，<code>CSet(collection set)</code>。</p>
<p>它的意思是在一次垃圾收集器中被收集的区域集合。</p>
<ul>
<li><p><code>Young GC</code>：选定所有新生代里的<code>region</code>。</p>
<p>通过控制新生代的<code>region</code>个数来控制<code>young GC</code>的开销。</p>
</li>
<li><p><code>Mixed GC</code>：选定所有新生代里的<code>region</code>，外加根据<code>global concurrent marking</code>统计得出收集收益高的若干老年代<code>region</code>。</p>
<p>在用户指定的开销目标范围内尽可能选择收益高的老年代<code>region</code>。</p>
</li>
</ul>
<p>在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？</p>
<p>我们需要在吞吐量跟<code>MaxGCPauseMillis</code>之间做一个平衡：</p>
<ul>
<li>如果<code>MaxGCPauseMillis</code>设置的<strong>过小</strong>，那么GC就会频繁，吞吐量就会下降。</li>
<li>如果<code>MaxGCPauseMillis</code>设置的<strong>过大</strong>，应用程序暂停时间就会变长。G1的默认暂停时间是200毫秒，我们可以从这里入手，调整合适的时间。</li>
</ul>
<h3 id="XX-G1HeapRegionSize-n设置G1区域大小"><a href="#XX-G1HeapRegionSize-n设置G1区域大小" class="headerlink" title="-XX:G1HeapRegionSize=n设置G1区域大小"></a><code>-XX:G1HeapRegionSize=n</code>设置G1区域大小</h3><p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。</p>
<p>目标是根据最小的 Java 堆大小划分出约 <code>2048</code> 个区域。</p>
<h3 id="XX-ParallelGCThreads-n设置STW工作线程个数"><a href="#XX-ParallelGCThreads-n设置STW工作线程个数" class="headerlink" title="-XX:ParallelGCThreads=n设置STW工作线程个数"></a><code>-XX:ParallelGCThreads=n</code>设置STW工作线程个数</h3><p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (<code>ParallelGCThreads</code>) 的 1/4 左右。</p>
<h3 id="XX-InitiatingHeapOccupancyPercent-45设置触发标记周期的堆占用率阀值"><a href="#XX-InitiatingHeapOccupancyPercent-45设置触发标记周期的堆占用率阀值" class="headerlink" title="-XX:InitiatingHeapOccupancyPercent=45设置触发标记周期的堆占用率阀值"></a><code>-XX:InitiatingHeapOccupancyPercent=45</code>设置触发标记周期的堆占用率阀值</h3><p>设置触发并发标记周期的 Java 堆占用率阈值。</p>
<p>默认占用率是整个 Java 堆的 <code>45%</code>。</p>
<blockquote>
<p>好书推荐：</p>
<p><a href="http://www.narihiro.info/g1gc-impl-book/" target="_blank" rel="noopener">《徹底解剖「G1GC」実装編》</a></p>
<p>《JVM G1源码分析和调优》</p>
</blockquote>
<blockquote>
<p>参考：</p>
<p>《JVM G1源码分析和调优》</p>
<p><a href="https://www.oracle.com/cn/technical-resources/articles/java/g1gc.html" target="_blank" rel="noopener">GC G1调优</a></p>
<p><a href="https://www.bilibili.com/video/BV1D741177rV/?p=2" target="_blank" rel="noopener">新一代垃圾回收器：G1详解（bilibili）</a></p>
<p><a href="https://wtff.oss-cn-shanghai.aliyuncs.com/live/G1GC.pdf" target="_blank" rel="noopener">G1详解.ppt</a></p>
<p><a href="[https://github.com/sunwu51/notebook/blob/master/19.09/java_jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.md](https://github.com/sunwu51/notebook/blob/master/19.09/java_jvm垃圾收集器.md)">java_jvm垃圾收集器.md</a></p>
<p><a href="https://www.jianshu.com/p/870abddaba41" target="_blank" rel="noopener">G1垃圾收集器之RSet</a></p>
<p><a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">Java Hotspot G1 GC的一些关键技术</a></p>
<p><a href="https://www.cnblogs.com/ASPNET2008/p/6496481.html" target="_blank" rel="noopener">深入理解Java G1垃圾收集器</a></p>
</blockquote>

      </div>
      
        <div class="prev-or-next">
          <div class="post-foot-next">
            
              <a href="/2020/07/24/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E5%8F%8A%E5%85%B6%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%9F/" target="_self">
                <i class="iconfont icon-chevronleft"></i>
                <span>PREV</span>
              </a>
            
          </div>
          <div class="post-attach">
            <span class="post-pubtime">2020-07-26</span>
            
                  <span class="post-tags">
                    <i class="iconfont icon-tags" title="标签 | tags"></i>
                    
                    <span class="span--tag">
                      <a href="/tags/JVM/" title="查看 JVM 标签">
                        <b>#</b> JVM
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="查看 垃圾收集器 标签">
                        <b>#</b> 垃圾收集器
                      </a>
                    </span>
                    
                    <span class="span--tag">
                      <a href="/tags/G1/" title="查看 G1 标签">
                        <b>#</b> G1
                      </a>
                    </span>
                    
                  </span>
              
          </div>
          <div class="post-foot-prev">
            
              <a href="/2020/07/27/%E9%9D%A2%E8%AF%95%E5%AE%98%EF%BC%9A%E8%AF%B4%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AFTIME-WAIT%EF%BC%9F/" target="_self">
                <span>NEXT</span>
                <i class="iconfont icon-chevronright"></i>
              </a>
            
          </div>
        </div>
      
    </div>
    
  <div class="post-catalog" id="catalog">
    <div class="title">目录</div>
    <div class="catalog-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#区别"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存划分"><span class="toc-text">内存划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分区类型分为？"><span class="toc-text">分区类型分为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Heap-Region大小确定方式？"><span class="toc-text">Heap Region大小确定方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果G1是启发式推断新生代的大小，那么当新生代变化时该如何实现？"><span class="toc-text">如果G1是启发式推断新生代的大小，那么当新生代变化时该如何实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配新的分区时，何时扩展？一次扩展多少内存？"><span class="toc-text">分配新的分区时，何时扩展？一次扩展多少内存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC模式"><span class="toc-text">GC模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#参数配置"><span class="toc-text">参数配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#收集过程"><span class="toc-text">收集过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Young-GC"><span class="toc-text">Young GC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mixed-GC（Concurrent-marking）"><span class="toc-text">Mixed GC（Concurrent marking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#那么什么时候会启动并发标记周期呢（Mixed-GC）？"><span class="toc-text">那么什么时候会启动并发标记周期呢（Mixed GC）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始标记（Initial-Marking）"><span class="toc-text">初始标记（Initial Marking）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TAMS是什么？"><span class="toc-text">TAMS是什么？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RootRegion扫描（Root-Region-Scan）"><span class="toc-text">RootRegion扫描（Root Region Scan）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#作用？"><span class="toc-text">作用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发标记（Concurrent-Marking）"><span class="toc-text">并发标记（Concurrent Marking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最终-重新标记（Final-Marking）"><span class="toc-text">最终&#x2F;重新标记（Final Marking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#筛选回收-清除垃圾（Live-Data-Counting-and-Evacuation）-（CleanUp）"><span class="toc-text">筛选回收&#x2F;清除垃圾（Live Data Counting and Evacuation）&#x2F;（CleanUp）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#混合式垃圾收集"><span class="toc-text">混合式垃圾收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-GC"><span class="toc-text">Full GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特点"><span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可预测停顿-amp-追求停顿时间"><span class="toc-text">可预测停顿 &amp; 追求停顿时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并行与并发"><span class="toc-text">并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空间整合"><span class="toc-text">空间整合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分代收集"><span class="toc-text">分代收集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#技术细节"><span class="toc-text">技术细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内存区域不固定"><span class="toc-text">内存区域不固定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1停顿预测模型（Pause-Prediction-Model）"><span class="toc-text">G1停顿预测模型（Pause Prediction Model）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#跨代引用"><span class="toc-text">跨代引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RSet（记忆集：Remember-Set）"><span class="toc-text">RSet（记忆集：Remember Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RSet实现过程"><span class="toc-text">RSet实现过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#赋值"><span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#修改"><span class="toc-text">修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection-Set（CSet）"><span class="toc-text">Collection Set（CSet）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CardTable（记录扫描跨代引用内存区域）"><span class="toc-text">CardTable（记录扫描跨代引用内存区域）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缺陷"><span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调优"><span class="toc-text">调优</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XX-MaxGCPauseMillis-200（建立G1停顿预测模型）"><span class="toc-text">-XX:MaxGCPauseMillis&#x3D;200（建立G1停顿预测模型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XX-G1HeapRegionSize-n设置G1区域大小"><span class="toc-text">-XX:G1HeapRegionSize&#x3D;n设置G1区域大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XX-ParallelGCThreads-n设置STW工作线程个数"><span class="toc-text">-XX:ParallelGCThreads&#x3D;n设置STW工作线程个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XX-InitiatingHeapOccupancyPercent-45设置触发标记周期的堆占用率阀值"><span class="toc-text">-XX:InitiatingHeapOccupancyPercent&#x3D;45设置触发标记周期的堆占用率阀值</span></a></li></ol></li></ol>
    </div>
  </div>

  
<script src="/js/catalog.js"></script>




    
      <div class="comments-container">
        


  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>

  <div id="vcomments"></div>

  <script>
    new Valine({
      el: '#vcomments',
      appId: 'bSYdbCIyQHwCwv9NC9Fes7mU-gzGzoHsz',
      appKey: 'zuj9HNh3w0O1O5t1nR1yeNHD',
      placeholder: '说出你的想法...',
      avatar: 'retro'
    })
  </script>

    <style>
      .comments-container .v .vempty {
        display: none!important;
      }
    </style>




      </div>
    
  </div>

  
        <div class="footer">
  <div class="social">
    <ul>
      
        <li>
          <a title="github" href="https://github.com/YYZ-coder" target="_blank" rel="noopener">
            <i class="iconfont icon-github"></i>
          </a>
        </li>
      
        <li>
          <a title="rss" href="/atom.xml">
            <i class="iconfont icon-rss"></i>
          </a>
        </li>
      
    </ul>
  </div>
  
    <div class="footer-more">
      <a href="">Copyright © YYZ-coder 2020</a>
    </div>
  
    <div class="footer-more">
      <a href="https://github.com/zchengsite/hexo-theme-oranges" target="_blank" rel="noopener">Theme by Oranges | Powered by Hexo</a>
    </div>
  
</div>

      </div>

      <div class="back-to-top hidden">
  <a href="javascript: void(0)">
    <i class="iconfont icon-chevronup"></i>
  </a>
</div>


<script src="/js/backtotop.js"></script>



    </div>
  </body>
</html>
